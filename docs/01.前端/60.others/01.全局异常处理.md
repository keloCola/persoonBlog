---
title: 全局异常处理
date: 2021-07-20 11:26:05
permalink: /pages/0daca1/
categories:
  - 前端
  - others
tags:
  - 真
---

[[toc]]

## 前言

对于前端来说，异常虽然不会导致计算机宕机，但是往往会导致用户的操作被阻塞。异常处理在程序设计中的重要性是毋庸置疑的。任何有影响力的 Web 应用程序都需要一套完善的异常处理机制，但实际上，通常只有服务端团队会在异常处理机制上投入较大精力。虽然客户端应用程序的异常处理也同样重要，但真正受到重视，还是最近几年的事。作为新世纪的杰出前端开发人员，我们必须理解有哪些异常，当发生异常时我们有哪些手段和工具可以利用。

### JavaScript中的Error

JavaScript中，`Error`是一个构造函数，通过它创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。构造一个Error的语法如下：

```js
// message: 错误描述
// fileName: 可选。被创建的Error对象的fileName属性值。默认是调用Error构造器代码所在的文件的名字。
// lineNumber: 可选。被创建的Error对象的lineNumber属性值。默认是调用Error构造器代码所在的文件的行号。

new Error([message[, fileName[, lineNumber]]])
```

### ECMAScript标准

#### Error有两个**标准**属性：

- `Error.prototype.name` ：错误的名字
- `Error.prototype.message`：错误的描述

例如，在chrome控制台中输入以下代码：

```js
var a = new Error('错误测试');
console.log(a); // Error: 错误测试
    			// at <anonymous>:1:9
console.log(a.name); // Error
console.log(a.message); // 错误测试
```

![image-20210720162008301](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210720162008.png)

#### Error只有一个**标准**方法：

- `Error.prototype.toString`：返回表示一个表示错误的字符串。

```js
var a = new Error('错误测试');
a.toString();  // "Error: 错误测试"
```

### 非标准的属性

各个浏览器厂商对于Error都有自己的实现。比如下面这些属性：

1. `Error.prototype.fileName`：产生错误的文件名。
2. `Error.prototype.lineNumber`：产生错误的行号。
3. `Error.prototype.columnNumber`：产生错误的列号。
4. `Error.prototype.stack`：堆栈信息。这个比较常用。

这些属性均不是标准属性，在生产环境中**谨慎使用**。不过现代浏览器差不多都支持了。

## 异常分类

### 常规7中分类

从根本上来说，异常就是一个数据结构，它存了异常发生时相关信息，譬如`错误码`、`错误信息`等。其中 message 属性是唯一一个能够保证所有浏览器都支持的属性，除此之外，IE、Firefox、Safari、Chrome 以及 Opera 都为事件对象添加了其它相关信息。譬如 `IE `添加了与 message 属性完全相同的 `description `属性，还添加了保存这内部错误数量的 `number `属性。Firefox 添加了 fileName、lineNumber 和 stack（包含堆栈属性）。所以，在考虑浏览器兼容性时，最好还是只使用` message `属性。

执行 JS 期间可能会发生的错误有很多类型。每种错误都有对应的错误类型，而当错误发生的时候就会抛出响应的错误对象。`ECMA-262 `中定义了下列 7 种错误类型：

- Error：错误的基类，其他错误都继承自该类型
- EvalError：与Eval ()相关的错误,Eval 函数执行异常,eval()本身没有正确执行。
- RangeError：数组越界,数值变量或参数超出其有效范围。例子：var a = new Array(-1);
- ReferenceError：尝试引用一个未被定义的变量时，将会抛出此异常即引用错误。 例子：console.log(b);
- SyntaxError：语法解析不合理即语法错误。例子：var a = ;
- TypeError：类型错误，用来表示值的类型非预期类型时发生的错误。例子：[1,2].split('.')
- URIError：以一种错误的方式使用全局 URI 处理函数而产生的错误，即给 `encodeURI`或 `decodeURl()`传递的参数无效。例子：decodeURI('%2')



> 除此之外还有一个 非ECMAScript标准。
>
> `InternalError`: 创建一个代表Javascript引擎内部错误的异常抛出的实例。 如: "递归太多"。

### 其他错误类型

##### DOMException

**DOMException**是W3C DOM核心对象，表示调用一个Web Api时发生的异常。什么是Web Api呢？最常见的就是DOM元素的一系列方法，其他还有XMLHttpRequest、Fetch等等等等，这里就不一一说明了。直接看下面一个操作DOM的例子：

```js
var node = document.querySelector('#app');
var refnode = node.nextSibling;
var newnode = document.createElement('div');
node.insertBefore(newnode, refnode);

// 报错：Uncaught DOMException: Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.
```

单从JS代码逻辑层面来看，没有问题。但是代码的操作不符合DOM的规则。

`DOMException`构造函数的语法如下：

```js
// message: 可选，错误描述。
// name: 可选，错误名称。常量，具体值可以在这里找到：https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException

new DOMException([message[, name]]);
```

`DOMException`有以下三个属性：

1. `DOMException.code`：错误编号。
2. `DOMException.message`：错误描述。
3. `DOMException.name`：错误名称。

以上面那段错误代码为例，其抛出的DOMException各属性的值为：

```js
code: 8
message: "Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node."
name: "NotFoundError"
```

##### `Promise`产生的异常

在`Promise`中，如果`Promise`被`reject`了，就会抛出异常：**`PromiseRejectionEvent`**。注意，下面两种情况都会导致`Promise`被`reject`：

1. 业务代码本身调用了`Promise.reject`。
2. `Promise`中的代码出错。

`PromiseRejectionEvent`的构造函数目前在浏览器中大多都不兼容，这里就不说了。

`PromiseRejectionEvent`的属性有两个：

1. `PromiseRejectionEvent.promise`：被`reject`的`Promise`。
2. `PromiseRejectionEvent.reason`：`Promise`被`reject`的原因。会传递给`reject`。`Promsie`的`catch`中的参数。

##### 加载资源出错

由于网络，安全等原因，网页加载资源失败，请求接口出错等，也是一种常见的错误。

#### 关于错误的小结

一个网页在运行过程中，可能发生四种错误：

1. JavaScript在运行过程，语言自身抛出的异常。
2. JavaScript在运行过程中，调用Web Api时发生异常。
3. Promise中的拒绝。
4. 网页加载资源，调用接口时发生异常。

## try—catch 

ECMA-262 第 3 版中引入了 try-catch 语句，作为 JavaScript 中处理异常的一种标准方式，基本的语法如下所示。这和 Java 中的 try-catch 语句是全完相同的。

```javascript
try {
  // 可能会导致错误的代码
} catch (error) {
  // 在错误发生时怎么处理
}
```

如果 try 块中的任何代码发生了错误，就会立即退出代码执行过程，然后执行 catch 块。此时 catch 块会接收到一个包含错误信息的对象，这个对象中包含的信息因浏览器而异，但共同的是`有一个保存着错误信息的 message 属性`。

`finally `子句在 try-catch 语句中是`可选的`，但是 finally 子句一经使用，其代码无论如何都会执行。换句话说，try 语句块中代码全部正常执行，finally 子句会执行；如果因为出错执行了 catch 语句，finally 子句照样会执行。`只要代码中包含 finally 子句，则无论 try 或 catch 语句中包含什么代码——甚至是 return 语句，都不会阻止 finally 子句执行`。来看下面函数的执行结果：

```javascript
function testFinally {
  try {
    return "出去玩";
  } catch (error) {
    return "看电视";
  } finally {
    return "做作业";
  }
  return "睡觉";
}
```

表面上调用这个函数会返回 "出去玩"，因为返回 "出去玩" 的语句位于 try 语句块中，而执行此语句又不会出错。实际上返回 "做作业"，因为最后还有 finally 子句，结果就会导致 try 块里的 return 语句被忽略，也就是说调用的结果只能返回 "做作业"。如果把 finally 语句拿掉，这个函数将返回 "出去玩"。因此，在使用 finally 子句之前，一定要非常清楚你想让代码怎么样。（思考一下如果 catch 块和 finally 块都抛出异常，catch 块的异常是否能抛出）

### try…catch局限性

try-catch `无法处理异步代码`和一些其他场景，比如说finally 

**SyntaxError **语法错误(比如用中文字符；)我们无法通过 try-catch 捕获到，不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。

## 异常分析

### 1. JS 代码错误

首先先看一张截图

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210720114421.png)

错误还是比较明显的，this 指向导致的问题。onOk 使用普通函数时，函数内执行语句的 this 上下文为 Antd.Modal 组件的实例，而 Antd.Modal 组件不存在 changeFilterType 这个方法。将 onOK 方法像 onCancel 方法一样改成箭头函数，将 this 指向父组件即可。

**TypeError** 类型在 JavaScript 中会经常遇到，在变量中保存着意外类型时，或者在访问不存在的方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定类型的操作时，变量的类型并不符合要求所致。再看几个例子：

```js
class People {
  constructor(name) {
    this.name = name;
  }
  sing() {}
}
const xiaoming = new People("小明");
xiaoming.dance(); // 抛出 TypeError
xiaoming.girlfriend.name; // 抛出 TypeError
```

代码错误一般在开发和测试阶段就能发现。用 try-catch 也能捕获到：

```javascript
// 代码
try {
  xiaoming.girlfriend.name;
} catch (error) {
  console.log(xiaoming.name + "没有女朋友", error);
}
// 运行结果
// 小明没有女朋友 TypeError: Cannot read property 'name' of undefined
```

### 2. JS 语法错误

我们修改一下代码，我们把英文分号改成中文分号:

```javascript
try {
  xiaoming.girlfriend.name；// 结尾是中文分号
} catch(error) {
  console.log(xiaoming.name + "没有女朋友", error);
}
// 运行结果
// Uncaught SyntaxError: Invalid or unexpected token
```

**SyntaxError **语法错误我们无法通过 try-catch 捕获到，不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。

不过凡事总有例外，线上还是能收到一些语法错误的告警，但多半是 JSON 解析出错和浏览器兼容性导致。

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210720114533.png)

再看几个例子：

```javascript
JSON.parse('{name:xiaoming}');      // Uncaught SyntaxError: Unexpected token n in JSON at position 1
JSON.parse('{"name":xiaoming}');    // Uncaught SyntaxError: Unexpected token x in JSON at position 8
JSON.parse('{"name":"xiaoming"}');  // 正常
var testFunc () => { };             // 在 IE 下会抛出 SyntaxError，因为 IE 不支持箭头函数，需要通过Babel等工具事先转译下
```

使用 JSON.parse 解析时出现异常就是一个很好的使用 try-catch 的场景：

```javascript
try {
  JSON.parse(remoteData); // remoteData 为服务端返回的数据
} catch {
  console.error("服务端数据格式返回异常，无法解析", remoteData);
}
```

#### 错误思考

并不是捕获到错误就结束了，捕获到错误后，我们需要思考当错误发生时：

- 错误是否是致命的，会不会导致其它连带错误
- 后续的代码逻辑还能不能继续执行，用户还能不能继续操作
- 是不是需要将错误信息反馈给用户，提示用户如何处理该错误
- 是不是需要将错误上报服务端

对应上面的问题这里就会有很多解决方案了，譬如：

- 如果是`服务器未知`异常导致，可以阻塞用户操作，弹窗提示用户`"服务器异常，请稍后重试"`。并提供给用户一个刷新的按钮；

```javascript
try {
  return JSON.parse(remoteData);
} catch (error) {
  Modal.fail("服务器异常，请稍后重试");
  return false;
}
```

- 如果是`数据异常导致`，可阻塞用户操作，弹窗提示用户`"服务器异常，请联系客服处理~"`，同时将错误信息`上报异常服务器`，开发人员通过异常堆栈和用户埋点定位问题原因；

```javascript
try {
  return JSON.parse(remoteData);
} catch (error) {
  Modal.fail("服务器异常，请联系客服处理~");
  logger.error("JSON数据解析出现异常", error);
  return false;
}
```

- 如果`数据解析`出错属于预料之中的情况，也有`替代的默认值`，那么当解析出错时直接使用默认值也可以；

```javascript
try {
  return JSON.parse(remoteData);
} catch (error) {
  console.error("服务端数据格式返回异常，使用本地缓存数据", erorr);
  return localData;
}
```

任何错误处理策略中最重要的一个部分，就是确定错误是否致命。

### 3. 异步错误

```javascript
try {
  setTimeout(() => {
    undefined.map(v => v);
  }, 1000)
} catch(e) {
  console.log("捕获到异常：", e);
}
 
Uncaught TypeError: Cannot read property 'map' of undefined
  at <anonymous>:3:15
```

并没有捕获到异常，`try-catch` 对`语法和异步错误却无能为力`，`捕获不到`，这是需要我们特别注意的地方。

### 4.跨域脚本错误

在进行错误捕获的过程中，很多时候并不能拿到完整的错误信息，得到的仅仅是一个`"Script Error"`。

#### 跨域脚本错误原因

当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而是使用简单的`"Script error."`代替。

一般而言，页面的JS文件都是放在CDN的，和页面自身的URL产生了跨域问题，所以引起了`"Script Error"`。

#### 跨域脚本错误解决办法

服务端添加`Access-Control-Allow-Origin`，页面在`script`标签中配置 `crossorigin="anonymous"`。这样，便解决了因为跨域而带来的`"Script Error"`问题。

#### 能绕过`Script Error`么

并不是所有的浏览器都支持`crossorigin="anonymous"`，也不是所有的服务端都能及时配置`Access-Control-Allow-Origin`，这种情况下，还有什么方法能在全局捕获到所有的错误，并拿到详细信息呢？

## 异常捕获

前端捕获异常分为全局捕获和单点捕获。

- 全局捕获代码集中，易于管理；
- 单点捕获作为补充，对某些特殊情况进行捕获，但分散，不利于管理。

1. 全局捕获
   - 通过全局的接口，将捕获代码集中写在一个地方，可以利用的接口有：
     - `window.addEventListener(‘error’)`
     - `window.addEventListener(“unhandledrejection”)`
     - `document.addEventListener(‘click’)` 等
   - 框架级别的全局监听，
     - 例如`aixos`中使用`interceptor`进行拦截，
     - `vue、react`都有自己的错误采集接口
   - 通过对全局函数进行封装包裹，实现在在调用该函数时自动捕获异常
   - 对实例方法重写（Patch），在原有功能基础上包裹一层，
     - 例如对`setTimeout`进行重写，在使用方法不变的情况下也可以异常捕获
2. 单点捕获
   - 在业务代码中对单个代码块进行包裹，或在逻辑流程中打点，实现有针对性的异常捕获：
   - `try…catch`
   - 专门写一个函数来收集异常信息，在异常发生时，调用该函数
   - 专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一模一样，只是在发生异常时可以捕获异常

### 1. window.onerror

当 `JS` 运行时错误发生时，`window` 会触发一个 `ErrorEvent` 接口的 `error` 事件，并执行`window.onerror()`。

- `message`：错误信息（字符串）
- `source`：发生错误的脚本URL（字符串）
- `lineno`：发生错误的行号（数字）
- `colno`：发生错误的列号（数字）
- `error`：Error对象（对象）

>注意，如果这个函数返回`true`，那么将会阻止执行浏览器默认的错误处理函数。

```javascript
/**
 * @param {String}  message    错误信息
 * @param {String}  source     出错文件
 * @param {Number}  lineno     行号
 * @param {Number}  colno      列号
 * @param {Object}  error      Error对象（对象）
 */
window.onerror = function (message, source, lineno, colno, error) {
  console.log("捕获到异常：", { message, source, lineno, colno, error });
};
```

> 注意：`同步错误可以捕获到`，但是，请注意 `window.error` `无法捕获` `静态资源异常`和` JS 代码错误`。

### 2. 静态资源加载异常

#### **方法一：onerror 来捕获**

```html
<link rel="stylesheet" href="http://cdn.xxx.com/styles/test.css" onerror="errorHandler(this)">
```

```html
<script>
  function errorHandler(error) {
    console.log("捕获到静态资源加载异常", error);
  }
</script>
<script src="http://cdn.xxx.com/js/test.js" onerror="errorHandler(this)"></script>
<link rel="stylesheet" href="http://cdn.xxx.com/styles/test.css" onerror="errorHandler(this)">
```

这样可以拿到静态资源的错误，但缺点很明显，代码的侵入性太强了，`每一个静态资源标签都要加上 onerror 方法`。

#### **方法二：addEventListener("error")**

```js
window.addEventListener('error', function(event) { ... })

```

我们调用`Object.prototype.toString.call(event)`，返回的是`[object ErrorEvent]`。可以看到`event`是`ErrorEvent`对象的实例。`ErrorEvent`是事件对象在脚本发生错误时产生，从`Event`继承而来。由于是事件，自然可以拿到`target`属性。`ErrorEvent`还包括了错误发生时的信息。

```js
event = new ErrorEvent()
```

- ErrorEvent.prototype.message:  字符串，包含了所发生错误的描述信息。
- ErrorEvent.prototype.filename:  字符串，包含了发生错误的脚本文件的文件名。
- ErrorEvent.prototype.lineno:  数字，包含了错误发生时所在的行号。
- ErrorEvent.prototype.colno:  数字，包含了错误发生时所在的列号。
- ErrorEvent.prototype.error:   发生错误时所抛出的 Error 对象。

注意，这里的`ErrorEvent.prototype.error`对应的Error对象，就是上文提到7中错误中的`Error`, `InternalError`，`RangeError`，`EvalError`，`ReferenceError`，`SyntaxError`，`TypeError`，`URIError`，甚至是`DOMException`中的一种。

```html
<!DOCTYPE html>
<html lang="zh">
 
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>error</title>
  <script>
    window.addEventListener('error', (error) => {
      console.log('捕获到异常：', error);
    }, true)
  </script>
</head>
 
<body>
  <img src="https://itemcdn.zcycdn.com/15af41ec-e6cb-4478-8fad-1a47402f0f25.png">
</body>
 
</html>
```
::: demo [vanilla]
```html
<html>
<img src="https://itemcdn.zcycdn.com/15af41ec-e6cb-4478-8fad-1a47402f0f25.png">

捕获异常:<span id="span1"></span>
</html>
   <script>
      const a = document.getElementById('span1')
    window.addEventListener('error', (error) => {
      console.log('捕获到异常：', error);
      a.textContent = JSON.stringify(error)
    }, true)
  </script>

```
:::


由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。

### 3 Promise 异常

Promise 中的异常不能被` try-catch 和 window.onerror 捕获`，这时候我们就需要监听 `unhandledrejection` 来帮我们捕获这部分错误。

```javascript
window.addEventListener("unhandledrejection", function (e) {
  e.preventDefault();
  console.log("捕获到 promise 错误了");
  console.log("错误的原因是", e.reason);
  console.log("Promise 对象是", e.promise);
  return true;
});

Promise.reject("promise error");
new Promise((resolve, reject) => {
  reject("promise error");
});
new Promise((resolve) => {
  resolve();
}).then(() => {
  throw "promise error";
});
```
![image-20210720133314352](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210720133314.png)

`e`就是`PromiseRejectionEvent`。我们只需要关注其`reason`就行。

### 4 React 异常

React 处理异常的方式不同。虽然` try-catch `适用于许多非普通 JavaScript 应用程序，但它`只适用于命令式代码`。因为 `React 组件是声明性的`，所以 try-catch 不是一个可靠的选项。为了弥补这一点，React 实现了所谓的`错误边界`[ErrorBoundary]。错误边界是 React 组件，`它“捕获子组件树中的任何地方的 JavaScript 错误”，同时还记录错误并显示回退用户界面`。

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    // 展示出错的UI
    this.setState({ hasError: true });
    // 将错误信息上报到日志服务器
    logErrorToMyService(error, info);
  }

  render() {
    if (this.state.hasError) {
      // 可以展示自定义的错误样式
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

但是需要注意的是，` error boundaries` 并不会捕捉下面这些错误：

- 事件处理器
- 异步代码
- 服务端的渲染代码
- 在 error boundaries 区域内的错误

我们可以这样使用 ErrorBoundary：

```xml
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary
```

### 5 Vue 异常

```javascript
Vue.config.errorHandler = (err, vm, info) => {
  console.error("通过vue errorHandler捕获的错误");
  console.error(err);
  console.error(vm);
  console.error(info);
};
```

`Vue`的源码中，在关键函数(比如钩子函数等)执行的时候，都加上`try{}catch(){}`，在`cacth`中处理捕获到的错误。看下面的源码。

```js
...
// vue源码片段
function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}
...
function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}
```

Vue中提供了`Vue.config.errorHandler`来处理捕获到的错误。

```js
// err: 捕获到的错误对象。
// vm: 出错的VueComponent.
// info: Vue 特定的错误信息，比如错误所在的生命周期钩子
Vue.config.errorHandler = (err, vm, info) => {
  console.error("通过vue errorHandler捕获的错误");
  console.error(err);
  console.error(vm);
  console.error(info);
};
```

如果开发者没有配置`Vue.config.errorHandler`，那么捕获到的错误会以`console.error`的方式输出。

### 6.请求异常

以最常用的 HTTP 请求库 axios 为例，模拟接口响应 401 的情况：

```javascript
// 请求
axios.get(/api/test/401")
// 结果
//Uncaught (in promise) Error: Request failed with status code 401
at createError (axios.js:1207)
at settle (axios.js:1177)
at XMLHttpRequest.handleLoad (axios.js:1037)
```

可以看出来` axios 的异常`可以当做` Promise 异常`来处理：

```javascript
// 请求
axios.get("http://localhost:3000/api/uitest/sentry/401")
.then(data => console.log('接口请求成功', data))
.catch(e => console.log('接口请求出错', e));
// 结果
接口请求出错 Error: Request failed with status code 401
at createError (createError.js:17)
at settle (settle.js:18)
at XMLHttpRequest.handleLoad (xhr.js:62)
```

一般接口 401 就代表用户未登录，就需要跳转到登录页，让用户进行重新登录，但如果每个请求方法都需要写一遍跳转登录页的逻辑就很麻烦了，这时候就会考虑使用 axios 的拦截器来做统一梳理，同理能统一处理的异常也可以在放在拦截器里处理。

```javascript
// Add a response interceptor
axios.interceptors.response.use(
  function (response) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
  },
  function (error) {
    if (error.response.status === 401) {
      goLogin(); // 跳转登录页
    } else if (error.response.status === 502) {
      alert(error.response.data.message || "系统升级中，请稍后重试");
    }
    return Promise.reject(error.response);
  }
);
```

### 7.劫持原生方法

看一个例子：

```js
const nativeAddEventListener = EventTarget.prototype.addEventListener; // 先将原生方法保存起来。
EventTarget.prototype.addEventListener = function (type, func, options) { // 重写原生方法。
    const wrappedFunc = function (...args) { // 将回调函数包裹一层try catch
        try { 
			return func.apply(this, args);
		} catch (e) {
			const errorObj = {
                ...
                error_name: e.name || '',
				error_msg: e.message || '',
				error_stack: e.stack || (e.error && e.error.stack),
				error_native: e,
                ...
			};
            // 接下来可以将errorObj统一进行处理。
        }
    }
    return nativeAddEventListener.call(this, type, wrappedFunc, options); // 调用原生的方法，保证addEventListener正确执行
}
```

我们劫持了原生的`addEventListener`代码，对`addEventListener`代码中的回调函数加了一层`try{}catch(){}`，这样，回调函数中抛出的错误会被`catch`住，**浏览器不会对`try-catch` 起来的异常进行跨域拦截**，所以我们可以拿到详细的错误信息。通过上面的操作，我们可以拿到所有监听事件的回调函数中的错误啦。其他的场景怎么办呢？继续劫持原生方法。

一个前端项目中，除了事件监听，接口请求也是一个频繁出现的场景。接着上面的代码，下面我们来劫持一下**Ajax**。

```js
    if (!XMLHttpRequest) {
        return;
    }

    const nativeAjaxSend = XMLHttpRequest.prototype.send; // 首先将原生的方法保存。
    const nativeAjaxOpen = XMLHttpRequest.prototype.open;


    XMLHttpRequest.prototype.open = function (mothod, url, ...args) { // 劫持open方法，是为了拿到请求的url
        const xhrInstance = this; 
        xhrInstance._url = url;
        return nativeAjaxOpen.apply(this, [mothod, url].concat(args));
    }

    XMLHttpRequest.prototype.send = function (...args) { // 对于ajax请求的监控，主要是在send方法里处理。

        const oldCb = this.onreadystatechange;
        const oldErrorCb = this.onerror;
        const xhrInstance = this;

        xhrInstance.addEventListener('error', function (e) { // 这里捕获到的error是一个ProgressEvent。e.target 的值为 XMLHttpRequest的实例。当网络错误(ajax并没有发出去)或者发生跨域的时候，会触发XMLHttpRequest的error, 此时，e.target.status 的值为:0，e.target.statusText 的值为:''
          
            const errorObj = {
                ...
                error_msg: 'ajax filed',
                error_stack: JSON.stringify({
                    status: e.target.status,
                    statusText: e.target.statusText
                }),
                error_native: e,
                ...
            }
          
            /*接下来可以对errorObj进行统一处理*/
          
        });


        xhrInstance.addEventListener('abort', function (e) { // 主动取消ajax的情况需要标注，否则可能会产生误报
            if (e.type === 'abort') { 
                xhrInstance._isAbort = true;
            }
        });


        this.onreadystatechange = function (...innerArgs) {
            if (xhrInstance.readyState === 4) {
                if (!xhrInstance._isAbort && xhrInstance.status !== 200) { // 请求不成功时，拿到错误信息
                   const errorObj = {
                        error_msg: JSON.stringify({
                            code: xhrInstance.status,
                            msg: xhrInstance.statusText,
                            url: xhrInstance._url
                        }),
                        error_stack: '',
                        error_native: xhrInstance
                    };
                    
                    /*接下来可以对errorObj进行统一处理*/
                    
                }
                
            }
            oldCb && oldCb.apply(this, innerArgs);
        }
        return nativeAjaxSend.apply(this, args);
    }
}
```

我们引用框架时，某些框架会用**`console.error`**的方法抛出错误。我们可以劫持`console.error`，来捕获错误。

```js
        const nativeConsoleError = window.console.error;
        window.console.error = function (...args) {
            args.forEach(item => {
                if (typeDetect.isError(item)) {
                   ...
                } else {
                   ...
                }
            });
            nativeConsoleError.apply(this, args);
        }
```

原生的方法有很多，还比如`fetch`、`setTimeout`等。这里不一一列举了。但是使用劫持原生方法以覆盖所有的场景是十分困难的。

### 8.setTimeout、setInterval、requestAnimationFrame

- 其实就是通过代理的方式把原来的方法拦截一下在调用真实的方法之前做一些自己的事情

```javascript
const prevSetTimeout = window.setTimeout;

window.setTimeout = function(callback, timeout) {
  const self = this;
  return prevSetTimeout(function() {
    try {
      callback.call(this);
    } catch (e) {
      // 捕获到详细的错误，在这里处理日志上报等了逻辑
      // ...
      throw e;
    }
  }, timeout);
}
```

### 9 总结

异常一共七大类，处理时需分清是致命错误还是非致命错误。

- 可疑区域增加 `try-catch`
- 全局监控 `JS` 异常 `window.onerror`
- 全局监控`静态资源`异常 `window.addEventListener`
- 捕获没有 `catch` 的 `Promise` 异常用 `unhandledrejection`
- `Vue errorHandler` 和 `React componentDidCatch`
- `Axios` 请求统一异常处理用拦截器 `interceptors`
- 使用日志监控服务收集用户错误信息

即

- 同步错误 
  -  try...catch 
  - window.onerror 
  - process.on('uncaughtException')
- 异步错误 
  - 例如setInterval、没有被await的异步函数等，是`不会被try...catch捕获`的
  - 但是会被`window.onerror`和`process.on('uncaughtException')`捕获。
- Promise错误
  - Promise.reject(new Error('some wrong'));
  - 不会被window.onerror和process.on('uncaughtException')捕获的，更不会被`try...catch`捕获，
  - 只能，`process.on('unhandledRejection')`以及`window.addEventListener('unhandledrejection')`

> 注意：在局部被try...catch了的错误是不会继续往上层抛出了的，所以全局处理的捕获是肯定捕获不到的，除非在catch到以后处理完成，将错误继续向上层throw




## 异常上报

即使我们前端开发完成后，会有一系列的 Web 应用的上线前的验证，如自测、QA 测试、code review 等，以确保应用能在生产上没有事故。

但是事与愿违，很多时候我们都会接到客户反馈的一些线上问题，这些问题有时候可能是你自己代码的问题。这样的问题一般能够在测试环境重现，我们很快的能定位到问题关键位置。但是，很多时候有一些问题，我们在测试中并未发现，可是在线上却有部分人出现了，问题确确实实存在的，这个时候我们测试环境又不能重现，还有一些偶现的生产的偶现问题，这些问题都很难定位到问题的原因，让我们前端工程师头疼不已。

目前有很多成熟的方案可供选择： ARMS、fundebug、BadJS、Sentry。

推荐了解一下[`sentry`](https://docs.sentry.io/platforms/javascript/)

sentry支持自动收集和手动收集两种错误收集方法，但是还不能捕捉到异步操作、接口请求中的错误，比如接口返回404、500等信息，此时我们可以通过Sentry.caputureException()进行主动上报

## window.onerror 和 window.addEventListener('error')的区别

1. 首先是**事件监听器**和**事件处理器**的区别。监听器只能声明一次，后续的声明会覆盖之前的声明。而事件处理器则可以绑定多个回调函数。
2. 资源( img 或 script )加载失败时，加载资源的元素会触发一个`Event`接口的`error`事件，并执行该元素上的`onerror()`处理函数。但这些error事件不会向上冒泡到window。不过，这些`error`事件能被`window.addEventListener('error')`捕获。也就是说，**面对资源加载失败的错误，只能用`window.addEventListerner('error')`，`window.onerror`**无效。


