---
title: 前端性能优化
date: 2021-07-15 17:36:13
permalink: /pages/975483/
categories:
  - 前端
  - 性能优化
tags:
  - 优化
---
`mksz448 - 前端性能优化--6大角度综合型优化方案[12h]`
<iframe :src="$withBase('/markmap/01.前端性能优化思维导图.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

[[toc]]

# 第1章 课程介绍

## 1-1 课程导学 【课程背景，大纲速览】

![image-20210713104909648](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713104909.png)

![image-20210713104923268](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713104923.png)

![image-20210713104944713](C:\Users\kelo\AppData\Roaming\Typora\typora-user-images\image-20210713104944713.png)

![image-20210713104959630](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713104959.png)

## 性能优化的思维导图

![前端性能优化](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713105749.png)

## 需要的技术储备

![image-20210713105857993](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713105858.png)



# 第2章 性能优化的指标和工具 (告别前端小白，成为大神的必经之路)

##  2-1 为什么要进行Web性能优化【企业刚需】

### 性能- web网站和应用的支柱

![image-20210713110238894](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713110238.png)

### 寻找性能瓶颈

- 了解性能指标- 多快才算快
- 利用测量工具和apis
- 优化问题，重新测试（迭代）永无止境

### 移动端挑战多

![image-20210713110508039](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713110508.png)

## 2-2 性能指标和优化目标【了解行业标准】

### 淘宝首页例子

![image-20210713110813418](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713110813.png)

### 瀑布流

- 纵向对比，让合适资源并行加载

- 横向对比，减缓资源加载过程

![横向对比](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713111535.png)![image-20210713111306485](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713111306.png)

### LIghthouse

![image-20210713112129082](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713112129.png)

### frames per second(FPS)

![image-20210713112245487](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713112245.png)

![image-20210713113110610](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713113110.png)

### 异步请求 1s内请求回来

### 性能优化- 加载

- 理解加载瀑布图（横向 纵向）
- 基于HAR存储于重建性能信息（右击保存当前控制台信息的那个）
- 速度指数（speed Index）4s
- 重要测量指标
  - Speed Index 
  - TTPB 发送请求到请求回来的时间
  - 页面加载时间
  - 首次渲染 First Contentful Paint

### 性能优化- 响应

- 交互动画的反馈时间
- 帧率FPS 60帧以上
- 异步请求的完成时间 1s内 超过的加loading

## 2-3 RAIL测量模型【黄金指南】

### 什么是RAIL

- Response
  - 并不是请求发送给服务器的那个
  - 指的是 当用户与网站进行交互的时候，有没有及时给用户反馈
- Animation 动画
  - 动画是否足够流畅
- Idle 空闲
  - 浏览器要有足够的空闲 来及时给用户反馈
  - ![image-20210713114323406](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713114323.png)
- Load加载
  - 资源网络加载的时间

### RAIL评估标准

- 响应：处理事件应在50ms以内完成

![image-20210713171255721](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713171255.png)

- 动画：每10ms产生1帧
- 空闲：尽可能增加空闲时间
- 加载：在5S内完成内容加载并可以交互

### 性能测量工具

- Chrome DevTools 开发调试、性能评测
- Lighthouse 网站整体质量评估
- webPageTest 多测试地点、全面性能报告

## 2-4 使用WebPageTest评估Web网站性能【快捷好用的在线分析工具】

- webpagetest.org[https://webpagetest.org/]

![image-20210713171911138](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713171911.png)

![image-20210713172137232](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713172137.png)

### 解读webpageTest 的报告

- waterfall chart 请求瀑布图
- first view 首次访问
- repeat view 二次访问

![image-20210713173027080](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713173027.png)![image-20210713172938112](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713172938.png)![image-20210713172919770](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210713172919.png)

### webPageTest 本地部署

#### 扩展知识：Docker 安装 也有安装包

1. 访问Docker官网文档，按需下载对应版本安装
   `https://docs.docker.com/get-docker/`

2. 注册docker id
   `https://hub.docker.com/signup`

3. 安装后点击工具栏的Docker图标，使用注册的docker id登录

#### 使用官方docker镜像  server 和agent

![image-20210714093209995](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093210.png)

![image-20210714093232763](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093232.png)

#### 运行一个sever实例

![image-20210714093300149](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093300.png)

#### 运行agent实例 注意实例

![image-20210714093334669](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093334.png)

### 创建server自定义镜像

#### 创建dockerfile 并添加

![image-20210714093507317](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093507.png)

![image-20210714093553876](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093553.png)

#### 创建localtions.ini 并添加配置

![image-20210714093829235](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093829.png)

![image-20210714093808978](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093809.png)

#### build

![image-20210714093918981](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714093919.png)

#### 运行我们自定义的镜像

![image-20210714094110485](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714094110.png)

### WebPageTest本地部署说明

1. 拉取镜像

   ```
   docker pull webpagetest/server
   
   docker pull webpagetest/agent
   ```

2. 运行实例

   ```
   docker run -d -p 4000:80 --rm webpagetest/server
   
   docker run -d -p 4001:80 --network="host" -e "SERVER_URL=http://localhost:4000/work/" -e "LOCATION=Test" webpagetest/agent
   ```

### mac 用户自定义镜像

1. 创建server目录

   ```
   mkdir wpt-mac-server
   cd wpt-mac-server
   ```

2. 创建Dockerfile，添加内容

   ```
   vim Dockerfile
   
   FROM webpagetest/server
   ADD locations.ini /var/www/html/settings/
   ```

3. 创建locations.ini配置文件，添加内容

   ```
   vim locations.ini
   
   [locations]
   1=Test_loc
   [Test_loc]
   1=Test
   label=Test Location
   group=Desktop
   [Test]
   browser=Chrome,Firefox
   label="Test Location"
   connectivity=LAN
   ```

4. 创建自定义server镜像

   ```
   docker build -t wpt-mac-server .
   ```

5. 创建agent目录

   ```
   mkdir wpt-mac-agent
   cd wpt-mac-agent
   ```

6. 创建Dockerfile，添加内容

   ```
   vim Dockerfile
   
   FROM webpagetest/agent
   ADD script.sh /
   ENTRYPOINT /script.sh
   ```

7. 创建script.sh， 添加内容

   ```
   vim script.sh
   
   #!/bin/bash
   set -e
   if [ -z "$SERVER_URL" ]; then
     echo >&2 'SERVER_URL not set'
     exit 1
   fi
   if [ -z "$LOCATION" ]; then
     echo >&2 'LOCATION not set'
     exit 1
   fi
   EXTRA_ARGS=""
   if [ -n "$NAME" ]; then
     EXTRA_ARGS="$EXTRA_ARGS --name $NAME"
   fi
   python /wptagent/wptagent.py --server $SERVER_URL --location $LOCATION $EXTRA_ARGS --xvfb --dockerized -vvvvv --shaper none
   ```

8. 修改script.sh权限

   ```
   chmod u+x script.sh
   ```

9. 创建自定义agent镜像

   ```
   docker build -t wpt-mac-agent .
   ```

10. 用新镜像运行实例 (注意先停掉之前运行的containers)

    ```
       docker run -d -p 4000:80 --rm wpt-mac-server
       
    ```

   docker run -d -p 4001:80 --network="host" -e "SERVER_URL=http://localhost:4000/work/" -e "LOCATION=Test" wpt-mac-agent

    ```   
    
    ```

##  2-5 使用LightHouse分析性能【一站式全面呈现性能指标】

### npm 安装使用方式

- 安装`npm install -g lighthouse`
- 使用`lighthouse 目标地址`
- 结果会生成一个本地报告的网页
- ![image-20210714094531501](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714094531.png)

![image-20210714094726426](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714094726.png)

![image-20210714094857039](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714094857.png)

### 直接在Chrome里使用就行了

## 2-6 使用Chrome DevTools分析性能【最大法宝】

### 请求大小与实际访问大小一致 可以在server中进行压缩

```js
app.use(compression());
app.use(express.static('build'));

```

```js
const express = require('express');
const app = express();
const fs = require('fs');
const compression = require('compression');
const path = require('path');


app.use(compression());
app.use(express.static('build'));

app.get('*', (req,res) =>{
    res.sendFile(path.join(__dirname+'/build/index.html'));
});

const listener = app.listen(process.env.PORT || 3000, function () {
    console.log(`Listening on port ${listener.address().port}`);
});

```

![image-20210714100214563](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714100214.png)

![image-20210714100231974](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714100232.png)

![image-20210714101420500](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714101420.png)

## 2-7 常用的性能测量APIs【不可不知，打开精细化、自定义测量的大门】

- 关键时间节点（`Navigation Timing , Resource Timing`）
- 网络状态（`Network APIs`）
- 客户端服务端协商（`HTTP Client Hints`）
- 网页显示状态（`UI APIs`）

### 常用apis计算方式

- DNS 解析耗时: domainLookupEnd - domainLookupStart
- TCP 连接耗时: connectEnd - connectStart
- SSL 安全连接耗时: connectEnd - secureConnectionStart
- 网络请求耗时 (TTFB): responseStart - requestStart
- 数据传输耗时: responseEnd - responseStart
- DOM 解析耗时: domInteractive - responseEnd
- 资源加载耗时: loadEventStart - domContentLoadedEventEnd
- First Byte时间: responseStart - domainLookupStart
- 白屏时间: responseEnd - fetchStart
- 首次可交互时间: domInteractive - fetchStart
- DOM Ready 时间: domContentLoadEventEnd - fetchStart
- 页面完全加载时间: loadEventStart - fetchStart
- http 头部大小： transferSize - encodedBodySize
- 重定向次数：performance.navigation.redirectCount
- 重定向耗时: redirectEnd - redirectStart

### Time to Interactive

```js
// 计算一些关键的性能指标
window.addEventListener('load', (event) => {
    // Time to Interactive
    let timing = performance.getEntriesByType('navigation')[0];
    console.log(timing.domInteractive);
    console.log(timing.fetchStart);
    let diff = timing.domInteractive - timing.fetchStart;
    console.log("TTI: " + diff);
})
```
![image-20210714102520219](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714102520.png)

###  观察长任务

```js
// 观察长任务
// 通过观察者
const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log(entry)
    }
})
//监听一个类型 这边我们要看长任务
observer.observe({entryTypes: ['longtask']})
```
![image-20210714102838946](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714102839.png)

### 见面可见性的状态监听

判断当前用户是否在看页面或者使用页面  

```js
// 见面可见性的状态监听
let vEvent = 'visibilitychange';
if (document.webkitHidden != undefined) {
    // webkit prefix detected 
    //webki事件名称
    vEvent = 'webkitvisibilitychange';
}

function visibilityChanged() {
    //页面不可见
    if (document.hidden || document.webkitHidden) {
        console.log("Web page is hidden.")
    } else {
        //页面可见
        console.log("Web page is visible.")
    }
}
// 时间监听 (事件，回调)
document.addEventListener(vEvent, visibilityChanged, false);
```

![image-20210714103426451](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714103426.png)

### 判断当前用户网络状态

```js
var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
var type = connection.effectiveType;
//监听事件的回调
function updateConnectionStatus() {
  console.log("Connection type changed from " + type + " to " + connection.effectiveType);
  type = connection.effectiveType;
}
//监听
connection.addEventListener('change', updateConnectionStatus);
```

![image-20210714103801617](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714103801.png)

# 第3章 渲染优化

## 3-1 浏览器渲染原理和关键渲染路径【大厂前端面试必考】

关键渲染路径（`critical rendering path`）

### 浏览器渲染流程

JavaScript—–>Style—–>Layout(布局)—–>Paint（绘制）—–>Composite（合成）

### 浏览器构建对象模型

- 构建DOM对象
  - HTML—–>DOM
- 构建CSSOM对象
  - CSS—–>CSSOM

### 浏览器构建渲染树

DOM+CSSOM —–> Render Tree

## 布局与绘制

- 布局记住 位置和大小
- 绘制 画出来
- 渲染树只包含网页需要的节点
- 布局计算每个节点精确的位置和大小 —–“盒模型”
- 绘制是像素化每个节点的过程

## 影响布局-回流的操作

- 添加/删除元素
- 操作Styles
- display：none
- offsetLeft，scrollTop，clientWidth
- 移动元素位置
- 修改浏览器大小，字体大小

## 3-2 回流与重绘, 如何避免布局抖动

### 连续布局操作导致强制布局更新来制造一下布局抖动

```js
// 获取页面上的卡片
let card = document.getElementsByClassName('aaa')
// 修改卡片宽度
const update=(timeStamp)=>{
    for(let i = 0;i<card.length;i++){
        // 通过offsetTop计算修改width
        card[i].style.width = ((Math.sin(card[i].offsetTop+timeStamp/1000)+1)*500)+'px'

    }
    window.requestAnimationFrame(update)
}
```

### 避免布局抖动

- 避免回流 translate
- 读写分离

## 3-3 使用FastDom【防止布局抖动的利器】

- 读 measure
- 写 mutate

```js
//  首先在HTML中引入fastDom文件
// <script src='./fastDom.js'></script>
// 获取页面上的卡片
let card = document.getElementsByClassName('aaa')
// 修改卡片宽度
const update = (timeStamp) => {
    for (let i = 0; i < card.length; i++) {
        //fastDom 读取
        fastdom.measure(() => {
            //    读取top值
            let top = card[i].offsetTop
            //    fastDom 赋值
            fastdom.mutate(() => {
                // 通过offsetTop计算修改width
                card[i].style.width = ((Math.sin(top + timeStamp / 1000) + 1) * 500) + 'px'

            })
        })

    }
    window.requestAnimationFrame(update)
}
```



## 3-4 复合线程(compositor thread)与图层(layers)

`拆分成多个图层以便于绘制`

- 将页面拆分图层进行绘制再进行复合
- 利用DevTools了解网页的图层拆分情况
- 那些样式仅影响复合（`只触发复合不影响布局和重绘`）
  - position ：transform：translate（npx,npx）—–移动
  - scale:transform:scale(n)  —大小
  - Rotation: transform:rotate(n deg)  —–旋转
  - Opacity : opacity:0…1                  —–透明

![image-20210714151721296](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714151721.png)



##  3-5 避免重绘

### chrome 工具设置

![image-20210714152805035](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714152805.png)

![image-20210714153102566](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714153102.png)

### 解决方案 利用will-change创建新的图层

劲量使用transform 和 提取到单独图层

![image-20210714153528134](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714153528.png)

```js
@keyframes rotate {
    0% {
        transform: rotate(0deg);
        opacity: 0.1;
        /*width: 300px;*/
        /*transform: scaleX(1);*/
    }
    50% {
        opacity: 0.5;
    }
    100% {
        transform: rotate(360deg);
        opacity: 0.1;
        /*width: 600px;*/
        /*transform: scaleX(2);*/
    }
}

```



##  3-6 高频事件防抖

滚动 touch 等等

### 问题复现

### 一帧的生命周期

![一帧的生命周期](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714154618.png)

### 解决问题

改进将实际触发的任务`changeWidth(pos);`放在`requestAnimationFrame`里面，

```js
        window.requestAnimationFrame(() => {
            changeWidth(pos);
        });
```
但这里还有一个问题，这里触发频率非常高的`pointermove`事件,如果一帧之内多次触发`requestAnimationFrame`也是没有意义的，我希望它一帧内只触发一次，这就是去抖动（debounce），通过一个变量`ticking`就可以控制住：

```js
let cards = document.getElementsByClassName('aaa');

//修改图片宽度
function changeWidth(position) {
    for (let i = 0; i < cards.length; i++) {
        cards[i].style.width = (Math.sin(position / 1000) + 1) * 500 + 'px';
    }
}

let ticking = false;
//利用Chrome DevTools来复现并分析抖动问题(pointer event)
window.addEventListener('pointermove', (e) => {
    let pos = e.clientX //获取鼠标的横坐标位置
    if (ticking) return; //如果ticking为true，说明已经有个requestAnimationFrame执行了

    ticking = true; //如果ticking为true，说明已经有个requestAnimationFrame执行了
    window.requestAnimationFrame(() => {
        changeWidth(pos);
        //如果requestAnimationFrame里面的事情执行了，ticking再调整回false，接着又可以触发下一个requestAnimationFrame，这样即使pointermove的触发频率很高我们也不按照它实际的触发频率去触发，而是按照requestAnimationFrame调度的频率。
        ticking = false;
    });
})
```
## 3-7 React时间调度实现【中高级前端需要了解的React调度原理】

- requestldlecallback的问题
- 通过rAF模拟rIC

### 什么是requestIdleCallback?

当关注用户体验，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用requestIdleCallback。因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。

requestIdleCallback用法示例

```js
    requestIdelCallback(myNonEssentialWork);
    
    
    function myNonEssentialWork (deadline) {
    
      // deadline.timeRemaining()可以获取到当前帧剩余时间
      while (deadline.timeRemaining() > 0 && tasks.length > 0) {
        doWorkIfNeeded();
      }
      if (tasks.length > 0){
        requestIdleCallback(myNonEssentialWork);
      }
    }
```

### requestIdleCallback和requestAnimationFrame有什么区别？

requestAnimationFrame的回调会在每一帧确定执行，属于高优先级任务，而requestIdleCallback的回调则不一定，属于低优先级任务。 我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢，如下所示：



![](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160236.webp)

图中一帧包含了用户的交互、js的执行、以及requestAnimationFrame的调用，布局计算以及页面的重绘等工作。 假如某一帧里面要执行的任务不多，在不到16ms（1000/60)的时间内就完成了上述任务的话，那么这一帧就会有一定的空闲时间，这段时间就恰好可以用来执行requestIdleCallback的回调，如下图所示：

![image-20210714155715585](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160248.png)



当程序栈为空页面无需更新的时候，浏览器其实处于空闲状态，这时候留给requestIdleCallback执行的时间就可以适当拉长，最长可达到50ms，以防出现不可预测的任务（用户输入）来临时无法及时响应可能会引起用户感知到的延迟。



![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160301.webp)



由于requestIdleCallback利用的是帧的空闲时间，所以就有可能出现浏览器一直处于繁忙状态，导致回调一直无法执行，这其实也并不是我们期望的结果（如上报丢失），那么这种情况我们就需要在调用requestIdleCallback的时候传入第二个配置参数timeout了？

```js
requestIdleCallback(myNonEssentialWork, { timeout: 2000 });

function myNonEssentialWork (deadline) {
  // 当回调函数是由于超时才得以执行的话，deadline.didTimeout为true
  while ((deadline.timeRemaining() > 0 || deadline.didTimeout) &&
         tasks.length > 0) {
       doWorkIfNeeded();
    }
  if (tasks.length > 0) {
    requestIdleCallback(myNonEssentialWork);
  }
}

```

如果是因为timeout回调才得以执行的话，其实用户就有可能会感觉到卡顿了，因为一帧的执行时间必然已经超过16ms了

### requestIdleCallback里面可以执行DOM修改操作吗？

强烈建议不要，从上面一帧的构成里面可以看到，requestIdleCallback回调的执行说明前面的工作（包括样式变更以及布局计算）都已完成。如果我们在callback里面做DOM修改的话，之前所做的布局计算都会失效，而且如果下一帧里有获取布局（如getBoundingClientRect、clientWidth）等操作的话，浏览器就不得不执行强制重排工作,这会极大的影响性能，另外由于修改dom操作的时间是不可预测的，因此很容易超出当前帧空闲时间的阈值，故而不推荐这么做。推荐的做法是在requestAnimationFrame里面做dom的修改，可以在requestIdleCallback里面构建Document Fragment，然后在下一帧的requestAnimationFrame里面应用Fragment。

除了不推荐DOM修改操作外，Promise的resolve(reject)操作也不建议放在里面，因为Promise的回调会在idle的回调执行完成后立刻执行，会拉长当前帧的耗时，所以不推荐。

### requestIdleCallback的兼容情况

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160339.webp)

# 第4章 代码优化 (快来看看怎样写出真正高性能的代码)

## 4-1 JS开销和如何缩短解析时间

![image-20210714160507374](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160507.png)

![image-20210714160616639](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160616.png)

![image-20210714160820467](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160820.png)

![1/3的时间都在处理JavaScript身上](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160850.png)

### 解决方法

![image-20210714160940318](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160940.png)

### 减少主线程工作量

- 注意合理规划首屏脚本

![image-20210714161013759](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161013.png)

### 渐进式启动

![image-20210714161122817](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161122.png)

### 总结

![image-20210714161140375](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161140.png)

## 4-2 V8编译原理

![image-20210714161355617](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161355.png)

![image-20210714162530620](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162530.png)

### 反优化的例子

```js
//在Node环境下运行
//引用
const {performance, PerformanceObserver} = require('perf_hooks');

const add = (a, b) => a+b;

const num1 = 1;
const num2 = 2;
//标记 开始测量
performance.mark('start');

for(let i = 0; i < 10000000; i++) {
	add(num1, num2);
}

// 在此之前的优化方式不适用于 下面的add 于是反优化之前方式，重新优化17行的add 耗能增加 可以通过注释来查看性能
// add(num1, 's');

for(let i = 0; i < 10000000; i++) {
	add(num1, num2);
}
//标记结束测量
performance.mark('end');
//进行一个监听 得到的对象
const observer = new PerformanceObserver((list) => {
	console.log(list.getEntries()[0]);
})
observer.observe({entryTypes: ['measure']});

//使用测量
performance.measure('测量1', 'start', 'end');
```

![image-20210714162215814](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162215.png)

### v8 的两个参数可以查看哪些优化哪些不优化

- `node --trace-opt` +文件名
- `node --trace-deopt` +文件名

![image-20210714162422218](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162422.png)

### 优化机制

- 脚本流
  - 超过30kb 会开一个新的来解析 后面再合并
- 字节码缓存
- 懒解析
  - 对于函数而言
  - 默认会开启
  - 真正用的时候才解析

## 4-3 函数优化

![image-20210714162757312](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162757.png)

### 饥饿解析

默认情况是懒解析 有时候我们遇到想要直接解析的函数 

懒解析再转饥饿解析耗费性能

于是便有强制饥饿解析

```js
export default () => {
    const add = (a, b) => a*b; // lazy parsing
    // const add = ((a, b) => a*b); // eager parsing
    const num1 = 1;
    const num2 = 2;
    add(num1, num2);
}
```

懒解析：v8 遇到add 的时候 只是先记住，但不解析里面的结构，等到使用add的时候再去解析

饥饿解析：v8遇到add的时候就解析内部结构

### Optimize

在webpack4.0以前，压缩的过程中有可能会吧（）直接给弄没了

于是便有optimize.js来解决这个问题

Example input:

```js
!function (){}()
function runIt(fun){ fun() }
runIt(function (){})
```

Example output:

```js
!(function (){})()
function runIt(fun){ fun() }
runIt((function (){}))
```

## 4-4 对象优化【JS对象避坑地图】

- 以相同顺序初始化对象成员，避免隐藏类的调整
- 实例化后避免添加新属性
- 尽量使用Array代替array-like对象
- 避免读取超过数组的长度
- 避免元素类型转换

### 以相同顺序初始化对象成员，避免隐藏类的调整

- 底层隐藏类型 

```js
// HindClass 我们简称 HC
/* 1 */
class RectArea { // HC0 隐藏对象0
    constructor(l, w) {
        this.l = l; // HC1
        this.w = w; // HC2
    }
}

const rect1 = new RectArea(3,4); // 创建了隐藏类HC0, HC1, HC2
const rect2 = new RectArea(5,6); // 相同的对象结构，可复用之前的所有隐藏类
```

对比一下

```js
const car1 = {color: 'red'}; // HC0
car1.seats = 4; // HC1

const car2 = {seats: 2}; // 没有可复用的隐藏类，创建HC2
car2.color = 'blue'; // 没有可复用的隐藏类，创建HC3
```



### 实例化后避免添加新属性

不推荐这样做

```js
const car1 = {color: 'red'}; // In-object 属性
car1.seats = 4; // Normal/Fast 属性，存储在property store里，需要通过描述数组间接查找
```

### 尽量使用Array代替array-like对象

```js
//类数组的foreach实现
Array.prototype.forEach.call(arrObj, (value, index) => { // 不如在真实数组上效率高
  console.log(`${ index }: ${ value }`);
});
//推荐方式
const arr = Array.prototype.slice.call(arrObj, 0); // 转换的代价比影响优化小
arr.forEach((value, index) => {
  console.log(`${ index }: ${ value }`);
});
```

### 避免读取超过数组的长度

```js
function foo(array) {
  for (let i = 0; i <= array.length; i++) { // 越界比较
    if(array[i] > 1000) { // 1.沿原型链的查找 2.造成undefined与数进行比较
        console.log(array[i]); // 业务上无效、出错
    }
  }
}
//[0,100,1000]
```

### 避免元素类型转换

```js
const array = [3, 2, 1]; // PACKED_SMI_ELEMENTS 满——整形

array.push(4.4); // PACKED_DOUBLE_ELEMENTS

```

![image-20210714170129611](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714170129.png)





## 4-5 HTML优化【必会】



## 4-6 CSS对性能的影响 【必会】

# 第5章 资源优化 (经典性能优化解决方案)

## 5-1 资源的压缩与合并【见效最明显的优化方法】

## 5-2 图片格式优化【多种图片格式，哪种最合适】

## 5-3 图片加载优化【突破大型网站图片加载的瓶颈

##  5-4 字体优化【千万不可忽略】

# 第6章 构建优化(揭开webpack性能优化的内幕)

##  6-1 webpack的优化配置【了解这些优化配置才敢说会用webpack】

## 6-2 webpack的依赖优化【小改动，大作用】

##  6-4 手把手教你做webpack的资源压缩

## 6-5 基于webpack的持久化缓存【大型企业级应用的必会技能】

## 6-6 基于webpack的应用大小监测与分析【webpack性能分析的法宝】

## 6-7 React按需加载的实现方式【中高级前端必会的React按需加载】

# 第7章 传输加载优化（前沿技术解决高访问量网站性能优化问题）

## 7-1 启用压缩Gzip【必会的传输压缩方案】

## 7-2 启用Keep Alive【通过一个参数提速连接】

## 7-3 HTTP资源缓存【必会的HTTP缓存方法】

## 7-4 一次性理解Service workers技术，给网站提速

## 7-5 HTTP 2的性能提升

## 7-6 用流行的SSR技术给前端减负

# 第8章 前沿优化解决方案

## 8-1 拯救移动端图标SVG【拯救移动端图标】

## 8-2 使用Flexbox优化布局（上）

##  8-3 使用Flexbox优化布局（下）

## 8-4 优化资源加载的顺序【给资源设置优先级】

## 8-5 预渲染页面【提前完成任务的意义】

## 8-6 Windowing提高列表性能【开源节流，用什么画什么】

## 8-7 使用骨架组件减少布局移动【论占位置的重要性】

# 第9章 性能优化问题面试指南【能胸有成竹的一步】

## 9-1 Web加载&渲染基本原理

##  9-2 首屏加载优化

## 9-3 JavaScript 内存管理

# 第10章 互联网外企offer与立足之道【能不能出国，就看这一章了】

## 10-1 互联网外企offer

## 10-2 英语与工作

