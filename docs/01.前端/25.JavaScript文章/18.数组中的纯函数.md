---
title: 数组中的纯函数
date: 2021-07-15 17:36:13
permalink: /pages/1a0105/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
---
# 数组中的纯函数与非纯函数

先说结论

> 纯函数

- concat
- map 
- filter 
- slice

> 非纯函数

- push pop shift unshif
- forEach
- some 
- every
- reduce
- splice

[toc]

## 广义纯函数

一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。这么说肯定比较抽象，我们把它掰开来看：

- 函数的返回结果只依赖于它的参数。
- 函数执行过程里面没有副作用。

```js
//  非纯函数 返回值与a相关，无法预料
const a = 1
const foo = (b) => a + b
foo(2)                    // => 3

// 纯函数 返回结果只依赖于它的参数 x 和 b，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。
const a = 1
const foo = (x, b) => x + b
foo(1, 2) // => 3

```



## 数组中的纯函数

- 不改变源数组（没有副作用）；
- 返回一个数组

 `concat map filter slice`

 slice 类似做一个深拷贝或者说是复制

`const arr4 = arr.slice()`

### concat()用于连接两个或多个数组，返回被连接数组的一个副本。

```js
arrayObject.concat(arrayX,arrayX,......,arrayX)
```
| 参数   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| arrayX | 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 |

#### 返回值

返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。

#### 实例

```js
var a = [1,2,3];
document.write(a.concat(4,5));
//输出
1,2,3,4,5
```

### map() 返回`新的数组`，每个元素为调用func的结果 `不会改变原素组`

```js
let result = arr.map(function(value) {
    value += 1
    console.log(value)
    return value
})
console.log(arr, result)
//map 不改变原数组的值
```

>arr 为 【1,2,3,4】输出【1,2,3,4】 【2,3,4,5】

### filter() 返回符合func条件的元素`数组`

```js
let result = arr.filter(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
// [1,2,3] [2]
//filter 不改变原数组数据
```

### slice

```js
const arr1 = arr.slice()//类似拷贝
const arr2 = arr.slice(1, 4)//截取第2-5个
const arr3 = arr.slice(2)//从第3个开始截取
const arr4 = arr.slice(-3)//截取导数三个数

```



## 非纯函数

- push pop shift unshif

- forEach

- some 
- every
- reduce
- splice



### forEach() 没有返回值，只是针对每个元素调用func

```js
// elem 当前遍历的对象 
// index 当前遍历的索引 
// array 当前遍历的数组本身
arr.forEach(function(elem, index, array) {
    if (arr[i] == 2) {
      // 不可以添加  continue break
    }
    console.log(elem, index)
})
```

这个语法看起来要简洁很多，不需要通过索引去访问数组项，然而它的缺点也是很明显，<font color='red'>不支持 break、continue </font>等。

```js
[1, 2, 3, 4, 5].forEach(function(i) {
    if (i === 2) {
        return;
    } else {
        console.log(i)
    }
})
```

这段代码的"本意"是从第一个元素开始遍历，遇到数组项 2 之后就结束遍历，不然打印出所遍历过的数值项。可是，事实让你大跌眼镜，因为它的输出是 1, 3, 4, 5。

> 注意
>
> forEach 的代码块中不能使用 break、continue，它会抛出异常。

### some() 返回<font color='red'>boolean</font>，判断是否有元素符合func条件

```js
let result = arr.some(function(value) {
    console.log(value)
    return value == 4
})
console.log(arr, result)
// [1,2,3] true
// some 返回Boolean 只要找到一个符合条件的就true
```

### every() 返回boolean，判断**每个元素**都符合func条件

```js
let result = arr.every(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
//[1,2,3] false 
// every 每一个都符合才会返回true
```

同样完成刚才的目标，使用 every 遍历就可以做到 break 那样的效果，简单的说 return false 等同于 break，return true 等同于 continue。如果不写，默认是 return false。

> 注意
>
> every 的代码块中不能使用 break、continue，它会抛出异常。

### **reduce()** 接收一个函数作为累加器

```js
// prev 上一次处理的元素
// cur 当前处理的元素
// index 当前处理的索引
// 原数组
// 0 从0 开始  arr.reduce(function() {}, 0) 方法+初始值
let sum = arr.reduce(function(prev, cur, index, array) {
    return prev + cur
}, 0)
console.log(sum)
let max = arr.reduce(function(prev, cur) {
    return Math.max(prev, cur)//返回最大值
})
console.log(max)
//数组去重 初始值为新的数组
let res = arr.reduce(function(prev, cur) {
    prev.indexOf(cur) == -1 && prev.push(cur)//当前信息是否包含在之前 无则推入
    return prev
}, [])
console.log(res)
```

### splice

```js
// splice 非纯函数
const arr = [10, 20, 30, 40, 50]
const spliceRes1 = arr.splice(1, 2)
console.log(spliceRes, arr) // [20,30]  [10,40,50]
---
const arr = [10, 20, 30, 40, 50]
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
console.log(spliceRes, arr)// [20,30]  [10,'a','b','c',40,50]
```

## 扩展：slice和splice的区别

功能区别（slice-切片，splice-剪接）

### slice

```js
const arr1 = arr.slice()//类似拷贝
const arr2 = arr.slice(1, 4)//截取第2-5个
const arr3 = arr.slice(2)//从第3个开始截取
const arr4 = arr.slice(-3)//截取导数三个数

```



### splice

```js
// splice 非纯函数
const arr = [10, 20, 30, 40, 50]
const spliceRes1 = arr.splice(1, 2)
console.log(spliceRes, arr) // [20,30]  [10,40,50]
---
const arr = [10, 20, 30, 40, 50]
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
console.log(spliceRes, arr)// [20,30]  [10,'a','b','c',40,50]

```

