---
title: 前端跳槽面试必备技能
date: 2021-07-15 17:36:13
permalink: /pages/71ee29/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
---

`慕课-前端跳槽面试必备技能`


# 第1章 课程介绍

## 1-1 前端面试-课程导学

![image-20210620155427564](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145401.png)

面试时间：一个小时到一个半小时

课程内容

- 面试准备
- 面试技巧
- 题目演练
- 知识梳理
- 复习指导

![image-20210620155631626](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145402.png)

![image-20210620155702454](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145403.png)

![image-20210620155738822](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145404.png)

![image-20210620155857446](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145405.png)

![image-20210620160013555](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145406.png)

# 第2章 面试准备

## 2-1 面试及环节设置

![image-20210620160303024](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145407.png)

![image-20210620160405734](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145408.png)

- `项目把控能力`

### 面试环节的设置

- 一面
  - 考察基础知识
- 二面/三面
  - 关注你的技术
- 三面/四面
  - 关注你的业务 在项目中所担任的角色
- 终面

### 面试准备

- 职位描述JD分析
- 业务分析或实战模拟
- 技术栈准备
- 自我介绍

##  2-2 职位分析（JD）（一）

![image-20210620161224141](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145409.png)

- 数据mock
- 前端组件库的建立
  - 基础扎实
  - 其他组件库源码的阅读
- 最新规范—>对技术有追求
- 组件化编程     面向对象
- HTML语义化  不要全部div div 要符合规范
- 前端架构分析与设计能力！项目的架构一整套！
- 代码编写要易读易维护  功能拆开写  能抽象就抽象
- 注意 了解 熟悉 精通
- `学一下前端构建环境 glup啥的  微信那个啥的项目有`
- 

## 2-3 职位分析（JD）（二）

![image-20210620163159606](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145410.png)

- 做动画 用dom svg canvas(可以做3d) css3
- web标准 es6 可访问性
-  `js 异常 `
  - js运行异常
  - js资源加载错误
- `工程化` 
  - webpack
  - sass
  - gulp

## 2-4  业务分析或实战模拟（一）

![image-20210620163936859](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145411.png)

-  基本布局
- 导航组件
- 简单动画 css3的动画效果
- 技术细节的查看 要看一下webpack
- element 直接看header 

![image-20210621105215013](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145412.png)

## 2-5 业务分析或实战模拟（二）

![image-20210621105319587](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145413.png)小方格拉伸

![image-20210621105616043](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145414.png)

- background：no -repeat center 0
- css3中的animation
- 异步加载方案 async promise
- jq 事件委托 事件代理

## 2-6 面试准备-技术栈准备

![image-20210621110350049](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145415.png)



##  2-7 面试准备-自我陈述（一）

![image-20210621110804279](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145416.png)

- 业绩要有业绩 
- 技术方案解决那些问题
- 参与开源项目



### 把握面试的沟通方向

我平时喜欢研究一些网站，喜欢看他们的技术原理和好玩的点，然后自己思考，喜欢尝试，看有没有更好的方案

到这个点就要收住

引导面试官去问 那你平时喜欢去逛什么网站呢

### 豁达自信的适度发挥

适度发挥 让对方欣赏你 而不要膨胀

## 2-8 面试准备-自我陈述（二）

![image-20210621113441521](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145417.png)

![image-20210621113542898](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145418.png)

![image-20210621143519984](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145419.png)

- 兴趣要和前端相符合
- 说半句留半句，引导对方来问



# 第3章 一面二面

面试技巧

- 准备要充分
- 知识要系统
- 沟通要简洁
- 内心要诚实
- 态度要谦虚
- 回答要灵活

## 3-1 页面布局（一）

![image-20210621150053014](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145420.png)

### 题目 ：假设高度已知，请写出三栏布局，其中左栏，右栏宽度各为300px，中间自适应

- 圣杯布局
- 双飞翼布局
- 绝对定位、浮动
- flex box
- 表格布局(虽然已经淘汰)
- `网格布局 grild`

![image-20210621163306255](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145421.png)

#### 初始化函数

```html
  <head>
    <meta charset="utf-8">
    <title>Layout</title>
      <!--初始化全局-->
    <style media="screen">
      html *{
        padding: 0;
        margin: 0;
      }
      .layout article div{
        min-height: 100px;
      }
    </style>
  </head>
```

#### float 方案

```html
<!--浮动布局  -->
    <section class="layout float">
      <style media="screen">
      .layout.float .left{
        float:left;
        width:300px;
        background: red;
      }
      .layout.float .center{
        background: yellow;
      }
      .layout.float .right{
        float:right;
        width:300px;
        background: blue;
      }
      </style>
      <h1>三栏布局</h1>
      <article class="left-right-center">
        <div class="left"></div>
        <div class="right"></div>
        <div class="center">
          <h2>浮动解决方案</h2>
          1.这是三栏布局的浮动解决方案；
          2.这是三栏布局的浮动解决方案；
          3.这是三栏布局的浮动解决方案；
          4.这是三栏布局的浮动解决方案；
          5.这是三栏布局的浮动解决方案；
          6.这是三栏布局的浮动解决方案；
        </div>
      </article>
    </section>
```

`H5中section和article和div的区别`

在Html5中，加入了很多用于“布局”的标签，他们有<header>、<nav>、<section>、<article>、<aside>、<footer>、<hgroup>等等。

其中<section>和<article>最为相似，而且和div标签貌似也有很大相似之处。 但看似相似，并不是真的相似，这些标签是为了布局而生的，自然有它们更精确的语义定位，或者说他们更将强调Html的语义。
`1.article`:
article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注。

article是一个特殊的section标签，它比section具有更明确的语义, 它代表一个独立的、完整的相关内容块。 div、section、article，语义是从无到有，逐渐增强的。div无任何语义，仅仅用作样式化或者脚本化的标签，对于一段主题性的内容，则就适用section，而假如这段内容可以脱离上下文，作为完整的独立存在的一段内容，则就适用 article。 原则上来说，能使用article的时候，也是可以使用section的，但是实际上，假如使用article更合适，那么就不要使用section。

```html
<article>
      <header>         
　　　　<h1>标题</h1>
           <p>发表日期：<time pubdate="pubdate">2010/10/10</time></p>
　　</header>
　　<p>article的使用方法</p>
　　<footer>
            <p><small>Copyright @ yiiyaa.net All Rights Reserverd</samll></p>
　　</footer>
</article>
```



注：article元素是可以嵌套使用的，内层的内容在原则上需要与外层的内容相关联。例如，一篇博客文章中，针对该文章的评论就可以使用嵌套article元素的方式；用来呈现评论的article元素被包含在表示整体内容的article元素里面。
`2.section:`

section用作一段有专题性的内容，一般在它里面会带有标题。 section典型的应用场景应该是文章的章节、标签对话框中的标签页、或者论文中有编号的部分。section元素用于对网站或应用程序中页面上的内容进行分块，section元素的作用是对页面上的内容进行分块，或者说对文章进行分段；一个section元素通常由内容及其标题组成，通常不推荐为那些没有标题的内容使用section元素。

article与section的嵌套方式一般如下：

```html
<article>
　　<header>
            <h1>article元素使用方法</h1>
　　　　<p>发表日期：<time pubdate="pubdate">2010/10/10</time></p>
　　</header>
　　<p>此标签里显示的是article整个文章的主要内容，，下面的section元素里是对该文章的评论</p>
　　<section>
            <h2>评论</h2>
　　　　<article>
                  <header>
　　　　　　　　<h3>发表者：maizi</h3>
　　　　　　　　<p><time pubdate datetime="2016-6-14">1小时前</time></p>
　　　　　　</header>  
　　　　　　<p>这篇文章很不错啊，顶一下！</p>
           </article> 
　　　　<article>
                  <header>            
　　　　　　　　<h3>发表者：小妮</h3>
                        <p><time pubdate datetime="2016-6-14T:21-26:00">1小时前</time></p>
　　　　　　</header>
　　　　<p>这篇文章很不错啊，对article解释的很详细</p>  
　　　　</article>
      </section>
</article>
```



示例内容分为几个部分，文章标题放在了header元素中，文章正文放在了header元素后面的p元素中，然后section元素把正文与评论进行了区分（是一个分块元素，用来把页面中的内容进行区分），在section元素中嵌入了评论的内容，评论中每一个人的评论相对来说又是比较独立的、完整的，因此对它们都使用一个article元素，在评论的article元素中，又可以分为标题与评论内容部分，分别放在header元素与p元素中。

但是关于section元素的使用禁忌总结如下：
（1）不要将section元素用作设置样式的页面容器，那是div元素的工作。
（2）如果article元素、aside元素或nav元素更符合使用条件，不要使用section元素。
（3）不要为没有标题的内容区块使用section元素。

`3.div`:

众所周知只是一个生命块的标签，并无具体语义，可用在任何场景，只是对比H5标签不好清晰看懂上下文。

总结：在H5中，article元素可以看成是一种特殊类型的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而article强调独立性。具体来说，如果一块内容相对来说比较独立的、完整的时候，应该使用article元素，但是如果你想将一块内容分成几段的时候，应该使用section元素。另外，在HTML5中，div元素变成了一种容器，当使用CSS样式的时候，可以对这个容器进行一个总体的CSS样式的套用。

#### 绝对定位

```html
<!-- 绝对布局 -->
    <section class="layout absolute">
      <style>

        .layout.absolute .left-center-right>div{
          /*绝对定位*/
          position: absolute;
        }
        .layout.absolute .left{
          left:0;
          width: 300px;
          background: red;
        }
        .layout.absolute .center{
          /*向左离300 向右里离300*/
          left: 300px;
          right: 300px;
          background: yellow;
        }
        .layout.absolute .right{
          right:0;
          width: 300px;
          background: blue;
        }
      </style>
      <h1>三栏布局</h1>
      <article class="left-center-right">
        <div class="left"></div>
        <div class="center">
          <h2>绝对定位解决方案</h2>
          1.这是三栏布局的浮动解决方案；
          2.这是三栏布局的浮动解决方案；
          3.这是三栏布局的浮动解决方案；
          4.这是三栏布局的浮动解决方案；
          5.这是三栏布局的浮动解决方案；
          6.这是三栏布局的浮动解决方案；
        </div>
        <div class="right"></div>
      </article>
    </section>
```

#### flexbox布局

```html
<!-- flexbox布局 -->
    <section class="layout flexbox">
      <style>
        .layout.flexbox{
          margin-top: 110px;
        }
        .layout.flexbox .left-center-right{
          /*声明容器有flex布局*/
          display: flex;
        }
        .layout.flexbox .left{
          width: 300px;
          background: red;
        }
        .layout.flexbox .center{
          /*中间自适应为1*/
          flex:1;
          background: yellow;
        }
        .layout.flexbox .right{
          width: 300px;
          background: blue;
        }
      </style>
      <h1>三栏布局</h1>
      <article class="left-center-right">
        <div class="left"></div>
        <div class="center">
          <h2>flexbox解决方案</h2>
          1.这是三栏布局的浮动解决方案；
          2.这是三栏布局的浮动解决方案；
          3.这是三栏布局的浮动解决方案；
          4.这是三栏布局的浮动解决方案；
          5.这是三栏布局的浮动解决方案；
          6.这是三栏布局的浮动解决方案；
        </div>
        <div class="right"></div>
      </article>
    </section>
```

#### table布局

![image-20210621165539644](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145422.png)

```html
<!-- 表格布局 -->
    <section class="layout table">
      <style>
        .layout.table .left-center-right{
          width:100%;
          height: 100px;
          display: table;
        }
        .layout.table .left-center-right>div{
          display: table-cell;
        }
        .layout.table .left{
          width: 300px;
          background: red;
        }
        .layout.table .center{
          background: yellow;
        }
        .layout.table .right{
          width: 300px;
          background: blue;
        }
      </style>
      <h1>三栏布局</h1>
      <article class="left-center-right">
        <div class="left"></div>
        <div class="center">
          <h2>表格布局解决方案</h2>
          1.这是三栏布局的浮动解决方案；
          2.这是三栏布局的浮动解决方案；
          3.这是三栏布局的浮动解决方案；
          4.这是三栏布局的浮动解决方案；
          5.这是三栏布局的浮动解决方案；
          6.这是三栏布局的浮动解决方案；
        </div>
        <div class="right"></div>
      </article>
    </section>
```

#### 网格布局

```html
 <!-- 网格布局 -->
    <section class="layout grid">
      <style>
        .layout.grid .left-center-right{
          /*容器网格布局*/
          width:100%;
          display: grid;
          /*行*/
          grid-template-rows: 100px;
          /*列*/
          grid-template-columns: 300px auto 300px;
        }
        .layout.grid .left-center-right>div{

        }
        .layout.grid .left{
          width: 300px;
          background: red;
        }
        .layout.grid .center{
          background: yellow;
        }
        .layout.grid .right{

          background: blue;
        }
      </style>
      <h1>三栏布局</h1>
      <article class="left-center-right">
        <div class="left"></div>
        <div class="center">
          <h2>网格布局解决方案</h2>
          1.这是三栏布局的浮动解决方案；
          2.这是三栏布局的浮动解决方案；
          3.这是三栏布局的浮动解决方案；
          4.这是三栏布局的浮动解决方案；
          5.这是三栏布局的浮动解决方案；
          6.这是三栏布局的浮动解决方案；
        </div>
        <div class="right"></div>
      </article>
    </section>
```



## 3-2 页面布局（二）



## 3-3 页面布局（总结）

![image-20210621170219292](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145423.png)

- 以上方案有什么优缺点
- 兼容性如何
- 最优的方案有什么

- 针对浮动 兼容性好 但必须清除浮动
- 绝对定位 快捷 但是脱离文档流了导致其他元素也要 有限
- flex布局贼好
- table布局在一些场景很实用，兼容性很好 但是有历史诟病
- grid 网格布局 新的技术

### 在高度设置的情况下，内容增加

![image-20210621171503997](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145424.png)

![image-20210621171521858](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145425.png)

- 浮动不处理的话不能用
- 绝对定位会溢出
- felx 会自动增高
- table也行
- grid网格布局会溢出

![image-20210621171818479](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145426.png)

### 页面布局小结

- 语义化掌握到位
- 页面布局理解深刻
- css基础知识扎实
- 思维灵活且积极上进
- 代码书写规范

### 页面布局的变通

![image-20210621172116800](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145427.png)

## 3-4 CSS盒模型

### 题目：谈谈你对css盒模型的认识

- 基本概念：标准模型和IE模型（怪异模型）
- 标准模型和IE模型的区别
- CSS如何设置这两种模型
- JS如何设置获取盒模型对应的宽和高
- 实例题（根据盒模型解释边距重叠）
- BFC（边距重叠解决方案）



### 基本概念：标准模型和IE模型（怪异模型）

![image-20210622093316203](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145428.png)

### CSS如何设置这两种模型

```cs
box-sizing:content-box;//标准模型 浏览器默认形式
box-sizing:border-box;//IE模型
```



### JS如何设置获取盒模型对应的宽和高

- dom.style.width/height  只能去内联的宽和高 取不到link或者imp中的
- dom.currentStyle.width /  height 仅IE支持
- window.getComputedStyle（dom).width / height 都支持
- dom.getBoundingClientRect().width  / height   用于计算一个元素的绝对位置

> 该`Element.getBoundingClientRect()`方法返回一个 [`DOMRect`](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)对象，提供有关元素大小及其相对于[视口的](https://developer.mozilla.org/en-US/docs/Glossary/Viewport)位置的信息。
>
> 返回值是一个[`DOMRect`](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)对象，它是包含整个元素的最小矩形，包括其填充和边框宽度。的 `left`，`top`，`right`，`bottom`， `x`，`y`，`width`，和`height`性质描述在像素整体矩形的位置和大小。`width`和以外的属性 `height`相对于视口的左上角。
>
> ![image-20210622094039048](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145429.png)

### 实例题（根据盒模型解释边距重叠）

问父元素的高度为多少

#### 正常情况 父100

![image-20210622095131634](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145430.png)

```html
      <section class="box" id="sec">
        <style media="screen">
          #sec{
            background: #f00;
          }
          .child{
            height: 100px;
            margin-top: 10px;
            background: yellow
          }
        </style>
        <article class="child"></article>
      </section>
```

#### 加bfc 父110

![image-20210622095117143](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145431.png)

```html
      <section class="box" id="sec">
        <style media="screen">
          #sec{
            background: #f00;
			overflow: hidden;
          }
          .child{
            height: 100px;
            margin-top: 10px;
            background: yellow
          }
        </style>
        <article class="child"></article>
      </section>
```



### BFC（边距重叠3解决方案）

BFC 的基本概念 ：块级格式化上下文

BFC的原理：

- BFC垂直方向边距重叠
- BFC不与float重叠  一般用来清除浮动
- BFC子元素即使是float也会参与计算
- 单独的块 区域内的元素不被外部影响

如何创建BFC：

- float 不为none
- position不是 static 或relative
- overflow 不为 visible
- display为table之类的

BFC应用场景：

- 

### BFC处理边距重叠

![image-20210622100143199](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145432.png)

```html
// margin 重叠了
      <section id="margin" >
        <style>
			/* 父元素背景为紫色 */
          #margin{
            background: pink;
            overflow: hidden;
          }
          #margin>p{
            margin: 5px auto 25px;
            background: red;
          }
        </style>
        <p>1</p>
		<p>2</p>
        <p>3</p>
      </section>
```

处理的方法就是在父元素加BFC，这里我哦们以p2为例子 加一个overflow：hidden

![image-20210622100226353](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145433.png)

```HTML
      <section id="margin" >
        <style>
			/* 父元素背景为紫色 */
          #margin{
            background: pink;
            overflow: hidden;
          }
          #margin>p{
            margin: 5px auto 25px;
            background: red;
          }
        </style>
        <p>1</p>
        <div style="overflow:hidden">
          <p>2</p>
        </div>
        <p>3</p>
      </section>
```



### BFC处理与float关系

正常情况 中间过高会溢出到左边

![image-20210622111025501](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145434.png)

```html
      <!-- BFC不与float重叠 -->
      <section id="layout" >
        <style media="screen">
          #layout{
            background: red;
          }
          #layout .left{
            float: left;
            width: 100px;
            height: 100px;
            background: pink;
          }
          #layout .right{
            height: 110px;
            background: #ccc;
          }
        </style>
        <div class="left"></div>
        <div class="right"></div>
      </section>
```

![image-20210622111116726](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145435.png)

```css
          #layout .right{
            height: 110px;
            background: #ccc;
            overflow: auto;
          }
```

### 清除浮动

![image-20210622111538138](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145436.png)

```html
      <!-- BFC子元素即使是float也会参与计算 -->
      <section id="float">
        <style media="screen">
          #float{
            background: red;
          }
          #float .float{
            float: left;
            font-size: 30px;
          }
        </style>
        <div class="float">我是浮动元素</div>
      </section>
```



![image-20210622111640292](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145437.png)

```html
      <!-- BFC子元素即使是float也会参与计算 -->
      <section id="float">
        <style media="screen">
          #float{
            background: red;
            overflow: auto;
            /*float: left;*/
          }
          #float .float{
            float: left;
            font-size: 30px;
          }
        </style>
        <div class="float">我是浮动元素</div>
      </section>
```

##  3-6 DOM事件（一）

- 基本概念：DOM事件的级别
- DOM事件模型（捕获 冒泡）
- DOM事件流
- 描述DOM事件捕获的具体流程
- Event对象的常见应用
- 自定义事件



### 基本概念：DOM事件的级别

DOM1 设计没有关于事件的存在 所以直接跳过了

DOM3 多了很多 比如鼠标事件

![image-20210624152725729](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145438.png)

### DOM事件模型（捕获 冒泡）

![image-20210624152906528](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145439.png)

### DOM事件流

三个阶段

![image-20210624152939497](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145440.png)

### 描述DOM事件捕获的具体流程

- window先接受
- document
- HTML  （document.documentElement;）
  - documentElement 属性以一个元素对象返回一个文档的文档元素。
  - HTML 文档返回对象为HTML元素。
  - **注意：** 如果 HTML 元素缺失，返回值为 *null*。
- body
- HTML结构往下传

![image-20210624153322274](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145441.png)

#### 捕获例子

![image-20210624154919507](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145442.png)

```js

        var ev = document.getElementById('ev');
        //注册捕获事件 true 捕获阶段触发 false 冒泡阶段 默认是false
        window.addEventListener('click', function (e) {
            console.log('window captrue 捕获阶段');
        }, true);
        //document
        document.addEventListener('click', function (e) {
            console.log('document captrue');
        }, true);
        //HTML 外层标签
        document.documentElement.addEventListener('click', function (e) {
            console.log('html captrue');
        }, true);
        //body
        document.body.addEventListener('click', function (e) {
            console.log('body captrue');
        }, true);
        ev.addEventListener('click', function (e) {
            console.log('ev captrue');
        }, true);

```



```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Event</title>
  </head>
  <body>
      <div id="ev">
        <style media="screen">
          #ev{
            width: 300px;
            height: 100px;
            background: red;
            color: #fff;
            text-align: center;
            line-height: 100px;
          }
        </style>
        目标元素
      </div>
  </body>
</html>

```

#### 冒泡例子

![image-20210624155759637](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145443.png)

```js
 /*
    * 冒泡ev 演示
    * */
    var ev = document.getElementById('ev');
    //注册捕获事件 true 捕获阶段触发 false 冒泡阶段 默认是false
    window.addEventListener('click', function (e) {
        console.log('window captrue 冒泡阶段');
    }, false);
    //document
    document.addEventListener('click', function (e) {
        console.log('document captrue');
    }, false);
    //HTML 外层标签
    document.documentElement.addEventListener('click', function (e) {
        console.log('html captrue');
    }, false);
    //body
    document.body.addEventListener('click', function (e) {
        console.log('body captrue');
    },false);
    ev.addEventListener('click', function (e) {
        console.log('ev captrue');
    },false);
```



### Event对象的常见应用

- 一个节点绑定了AB两个事件 现在执行完了A不想让他执行B 于是在A中写入`event.stopImmediatePropagation()`
- `stopImmediatePropagation`:阻止事件冒泡并且阻止该元素上同事件类型的监听器被触发

![image-20210624153935664](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145444.png)

### 自定义事件

event：可以指定事件名 **new Event(typeArg, eventInit)**

coustomEvent:可以指定事件名+数据

![image-20210624154012581](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145445.png)

```js
    /*自定义事件演示*/
    var eve = new Event('test');
    //事件监听
    ev.addEventListener('test', function () {
        console.log('test dispatch');
    });
    setTimeout(function () {
        //事件触发 注意eve 是名 而不是test
        ev.dispatchEvent(eve);
    }, 1000);
```

## 3-8 HTTP协议类

- HTTP 协议的主要特
- HTTP 报文的组成部分
- HTTP 方法
- POST 和 GET 的区别
- HTTP状态码
- 什么是持久连接
- 什么是管线化

### HTTP 协议的主要特点

- 简单快速
  - 每个资源是固定的 输入URL就行
  - 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- 灵活
  - 通过同一个HTTP就可以传输不同类型的数据，主要在头有个类型控制
  - HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
- `无连接`
  - 连接一次就会断掉
  - **无连接的含义**是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- `无状态`
  - **无状态**是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。
  - HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
  - HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。
  - 客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
  - **Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了**（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。

### HTTP 报文的组成部分

![image-20210624161905525](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145446.png)

![image-20210624170032028](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145447.png)

![image-20210624170135653](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145448.png)

### HTTP 方法

![image-20210624170149266](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145449.png)

### POST 和 GET 的区别

- 无害 不会重复提交
- 长度限制一般是2kb但是不同浏览器有不同的限制

![image-20210624170213785](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145450.png)

### HTTP状态码

![image-20210624170511150](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145451.png)

![image-20210624170547321](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145452.png)

![image-20210624170645760](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145453.png)



### 什么是持久连接

![image-20210624170726457](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145454.png)

http支持持久连接 ，这个连接是在http1.1版本可以，1.0不行



### 什么是管线化

![image-20210624170856572](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145455.png)

![image-20210624171000459](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145456.png)



## 3-9 原型链

- 创建对象的几种方法
- 原型，构造函数、实例、原型链
- instanceof的原理
- new运算符

### 创建对象的几种方法

![image-20210624171604592](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145457.png)



```js
      // 第一种方式：字面量
      var o1 = {name: 'o1'};
      var o2 = new Object({name: 'o2'});
```

```js
      // 第二种方式：构造函数
      var M = function (name) { this.name = name; };
      var o3 = new M('o3');
```

```js
      // 第三种方式：Object.create
      var p = {name: 'p'};
      var o4 = Object.create(p);
```

![image-20210624172052826](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145458.png)

**`Object.create()`**方法创建一个新对象，使用现有的对象来提供新创建的对象的`_ proto _`。 

Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法

Object.create()方法接受两个参数:Object.create(obj,propertiesObject) ;

obj:一个对象，应该是新创建的对象的原型。

propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。

#### 总结：

使用Object.create()是将对象继承到`_ proto_`属性上

**使用Object.create()是将对象继承到原型链上，然后可以通过对象实例的`__ proto __`属性进行访问原型链上的属性**

![image-20210625095635227](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145459.png)

### 原型，构造函数、实例、原型链

![image-20210624172121035](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145500.png)

```js
// 第二种方式：构造函数
// M 构造函数
// o3 实例  M+new-->o3
// o3._proto_  原型对象
  var M = function (name) { this.name = name; };
  var o3 = new M('o3');
```


### instanceof的原理

![image-20210624173025432](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145501.png)

![image-20210625093339751](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145502.png)

![image-20210625093427546](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145503.png)

`用constructor 比用instanceof 来的严谨`

### new运算符

![image-20210625093514533](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145504.png)

```js
    //new 运算法原理
    var new2 = function (func) {
        //创建一个新对象 并将构造函数的原型对象 继承 
        var o = Object.create(func.prototype);
        //执行构造函数
        var k = func.call(o);
        //判断 如果返回对象则替换 否则返回原本定义的对象
        if (typeof k === 'object') {
            return k;
        } else {
            return o;
        }
    };

```

![image-20210625094341407](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145505.png)

## 3-11 面向对象

- 类与实例
  - 类的声明
  - 生成实例
- 类与继承
  - 如何实现继承
  - 继承的几种方式



### 类的声明

```js
    /*
    * 类的声明
    * */
    function Animal() {
        //通过this表示这是一个构造函数
        this.name = 'name'
    }

    /*
    * ES6中class的声明
    *
    * */
    class Animal2 {
        constructor() {
            this.name = name
        }
    }
```



### 生成实例

```js
    /*
    * 实例化一个类
    * */
    console.log(new Animal(),new Animal2())
```



![image-20210625102019436](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145506.png)

### 如何实现继承

` 继承的本质就是原型链`

#### 构造函数方式继承

- 构造函数继承中并不是真正的继承  不会继承`父类原型对象上的方法`
- 如果属性都在构造函数里 那没问题



```js
    /*
    * 借助构造函数实现继承
    * */
    function Parent1() {
        this.name = 'this is parent1'
    }
    //在parent1 的 原型对象上有个方法 但在构造函数中 是无法继承这个方法的
    Parent1.prototype.say = function () {

    }
    function Child1() {
        //改变父构造函数this的指向 指向child的实例 实现继承
        Parent1.call(this)//apply 也行 改变上下文
        this.type = 'this is child1`s type'
    }

    //    实例化child1
    console.log(new Child1())
```

![image-20210625102945488](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145507.png)

#### 借助原型链实现继承

```js
    /*
    * 借助原型链实现继承
    * */
    function Parent2() {
        this.name = 'Parent2'
    }

    function Child2() {
        this.type = 'child2'
    }

    //    重点！
    Child2.prototype = new Parent2()
    console.log(new Child2)
```

![image-20210625104340471](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145508.png)

缺点： 当实例化两个对象，s1 s2 = new child2(),由于是引用的，地址相同 ,改变s1 同时s2也会受影响

#### 组合方式

```js
/*
    * 组合方式
    * */
    function Parent3() {
        this.name = 'Parent3'
        this.p = [1, 2, 3]
    }

    function Child3() {
        this.type = 'child3'
        //    构造函数继承
        Parent3.call(this)
    }

    //    原型链继承
    Child3.prototype = new Parent3()
    var s3 = new Child3()
    var s4 = new Child3()
    s3.p.push(4)
    console.log(s3, s4)
```

#### 组合方式优化

```js
    function Child4() {
        this.type = 'child4'
        //    构造函数继承
        Parent4.call(this)
    }

    //    原型链继承
    Child4.prototype = Parent4.prototype
```

存在一个问题：`由于直接指定了parent4的prototype`，child4的构造函数就相当于也指向了parent4的构造函数，会出现无法判断归属，例如：

```js
var s5 = new Child4()
    var s6 = new Child4()
    s5.p.push(5)
    console.log(s5, s6)
    console.log(s5 instanceof Child4,s5 instanceof Parent4)//true true
    console.log(s5.constructor === Parent4  )//true
```

#### 解决组合方式优化的问题

```js
    //    原型链继承
    Child5.prototype = Object.create(Parent5.prototype)
    //    覆盖一下 不然还是找到父类的
    Child5.prototype.constructor = Child5
```

#### 综上 `这几种方式都要写出来 切记不要就只写最优的`

```js
    /*
* 组合方式 优化问题解决
* */
    function Parent5() {
        this.name = 'Parent5'
        this.p = [1, 2, 5]
    }

    function Child5() {
        this.type = 'child5'
        //    构造函数继承
        Parent5.call(this)
    }

    //    原型链继承
    Child5.prototype = Object.create(Parent5.prototype)
    //    覆盖一下 不然还是找到父类的
    Child5.prototype.constructor = Child5
```



### 继承的几种方式

- 构造函数方式继承
- 借助原型链实现继承
- 组合方式
- 组合方式优化1
- 组合方式优化2 最优解

## 3-13 通信类

- 什么是同源策略及限制
- 前后端如何通信
- 如何创建ajax
- 跨域通信的几种方式



### 什么是同源策略及限制

- 源
  - 协议
  - 域名 
  - 端口 默认是80
- 限制
  - Cookie，localStorage和indexDB无法读取
  - DOM无法获取
  - Ajax是同源的方式，不同源请求不能发送

![image-20210626000306353](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145509.png)

### 前后端如何通信

- ajax 同源下的通信方式
- websock 不受同源策略的限制
- CROS 支持同源以及跨域

### 如何创建ajax

- XMLHttpRequest 对象的工作流程
- 兼容性处理 主要针对Chrome高版本
- 事件的触发条件
- 事件的触发顺序

```js
function ajax(url) {
    const p = new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest()
        xhr.open('GET', url, true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(
                        JSON.parse(xhr.responseText)
                    )
                } else if (xhr.status === 404 || xhr.status === 500) {
                    reject(new Error('404 not found'))
                }
            }
        }
        xhr.send(null)
    })
    return p
}
const url = '/data/test.json'
ajax(url)
.then(res => console.log(res))
.catch(err => console.error(err))
```

```js
//模拟一个ajax请求
var opt = {
    url: '',
    type: 'get',
    data: {},
    success: function () {
    },
    error: function () {
    },
};
function request(opt){
    if (opt.url) {
        //判断是否支持XMLHttpRequest 不支持的话兼容IE
        var xhr = XMLHttpRequest
            ? new XMLHttpRequest()
            : new ActiveXObject('Microsoft.XMLHTTP');
        var data = opt.data,
            url = opt.url,
            type = opt.type.toUpperCase(),
            dataArr = [];

        for (var k in data) {
            dataArr.push(k + '=' + data[k]);
        }
        // get 方式处理
        if (type === 'GET') {
            //传参data转换成key value
            url = url + '?' + dataArr.join('&');
            xhr.open(type, url.replace(/\?$/g, ''), true);
            xhr.send();
        }
        //post方式处理
        if (type === 'POST') {
            xhr.open(type, url, true);
            xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            xhr.send(dataArr.join('&'));
        }
        //响应
        xhr.onload = function () {
            // 206 媒体资源请求成功
            if (xhr.status === 200 ||xhr.status === 206|| xhr.status === 304) {
                var res;
                if (opt.success && opt.success instanceof Function) {
                    res = xhr.responseText;
                    if (typeof res ===  'string') {
                        res = JSON.parse(res);
                        opt.success.call(xhr, res);
                    }
                }
            } else {
                if (opt.error && opt.error instanceof Function) {
                    opt.error.call(xhr, res);
                }
            }
        };
    }
}

var ajax = new request()
ajax(opt)
```



### 跨域通信的几种方式

- JSONP
- Hash
- postMessage
- WebSocket
- CORS 支持跨域通信的Ajax

#### JSONP

- 原理 利用Script 标签实现的

```js
/*
*  动态创建Script便签
 */
function createScript(url, charset) {
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    charset && script.setAttribute('charset', charset);
    script.setAttribute('src', url);
    script.async = true;
    return script;
};

/**
 * [function jsonp]
 * @param  {[type]} url      [description]
 * @param  {[type]} onsucess [description]
 * @param  {[type]} onerror  [description]
 * @param  {[type]} charset  [description]
 * @return {[type]}          [description]
 */
function jsonp(url, onsuccess, onerror, charset) {
    //设置回调名
    var callbackName = 'tt_player'
    window[callbackName] = function () {
        if (onsuccess && util.isFunction(onsuccess)) {
            onsuccess(arguments[0]);
        }
    };
    //动态创建Script便签
    var script = createScript(url + '&callback=' + callbackName, charset);
    //监听脚本加载事件
    script.onload = script.onreadystatechange = function () {
        if (!script.readyState || /loaded|complete/.test(script.readyState)) {
            script.onload = script.onreadystatechange = null;
            // 移除该script的 DOM 对象
            if (script.parentNode) {
                script.parentNode.removeChild(script);
            }
            // 删除函数或变量
            window[callbackName] = null;
        }
    };
    script.onerror = function () {
        if (onerror && util.isFunction(onerror)) {
            onerror();
        }
    };
    //增加script标签
    document.getElementsByTagName('head')[0].appendChild(script);
};
```

#### HASH 方式跨域

```js
      // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B
      // 在A中伪代码如下：
      var B = document.getElementsByTagName('iframe');
      B.src = B.src + '#' + 'data';
      // 在B中的伪代码如下
      window.onhashchange = function () {
          var data = window.location.hash;
      };
```

#### PostMessage 跨域方式

```js
// postMessage
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
//message，targetOrigin接收方的源
//A下 去获取B 窗口下的window
window.postMessage('data', 'http://B.com');
//在窗口B中监听
window.addEventListener('message', function (event) {
    console.log(event.origin);//判断发送的源
    console.log(event.source);//A下的引用window
    console.log(event.data);
}, false);

```

#### webSocket 跨域

```js
// Websocket【参考资料】http://www.ruanyifeng.com/blog/2017/05/websocket.html
//声明webSocket
var ws = new WebSocket('wss://echo.websocket.org');
ws.onopen = function (evt) {
    console.log('Connection open ...');
    // 请求发送

    ws.send('Hello WebSockets!');
};
//接收事件
ws.onmessage = function (evt) {
    console.log('Received Message: ', evt.data);
    ws.close();
};
//连接关闭
ws.onclose = function (evt) {
    console.log('Connection closed.');
};
```

#### CORS 跨域

- 了解新的通信方式 fetch

```js
// CORS【参考资料】http://www.ruanyifeng.com/blog/2016/04/cors.html
// url（必选），options（可选）
fetch('/some/url/', {
    method: 'get',
}).then(function (response) {

}).catch(function (err) {
    // 出错了，等价于 then 的第二个参数，但这样更好用更直观
});
```



## 3-14 安全类

- CSRF
- xss

### csrf

![image-20210626005740544](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145510.png)

![image-20210626005901296](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145511.png)

![image-20210626010031235](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145512.png)

- referer 来源验证





### xss

![image-20210626010114977](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145513.png)

![image-20210626010130829](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145514.png)

- 向页面注入脚本



## 3-15 算法类

- 排序
- 堆栈、 队列、链表
- 递归
- 波兰式和逆波兰式





### 排序

![image-20210626010756158](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145515.png)

![image-20210626010824407](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145516.png)



### 堆栈、 队列、链表

![image-20210626011250127](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145517.png)

### 递归

![image-20210626011259955](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145518.png)

### 波兰式和逆波兰式

![image-20210626011351482](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145519.png)

### 算法技巧

- 基本方式
- 可以问面试官提示
- 实在不会就用伪代码 能分析到哪就怎么搞
- 知识面广

# 第4章 二面三面

面试技巧

- 知识面要广
- 理解要深刻
- 内心要诚实
- 态度要谦虚
- 回答要灵活
- 要学会赞美

![image-20210626012310792](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145520.png)

## 4-1 渲染机制

- 什么是DOCTYPE及作用
- 浏览器渲染过程
- 重排Reflow
- 重绘Repaint
- 布局Layout



### 什么是DOCTYPE及作用

![image-20210626012559908](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145521.png)

![image-20210626012628357](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145522.png)

### 浏览器渲染过程

![image-20210626012751236](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145523.png)

![image-20210626012907307](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145524.png)

![image-20210626012943102](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145525.png)

![image-20210626013000575](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145526.png)

![image-20210626013013935](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145527.png)

### 重排Reflow

![image-20210626013044060](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145528.png)

### 重绘Repaint

Repaint无法避免 但是可以尽量减少 其实一次性将节点加入就行了

![image-20210626013230607](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145529.png)

### 布局Layout

## 4-2 js运行机制

```js
    console.log(1);
    setTimeout(function () {
        console.log(2);
    }, 0);
    console.log(3);
    console.log(4);
//1 3 4 2
```

```js
    console.log('A');
    while (true) {
    }
    console.log('B');
//A
```

```js
    console.log('A');
    setTimeout(function () {
        console.log('B');
    }, 0);
    while (1) {

    }
//A
```

```js
    for (var i = 0; i < 4; i++) {
        setTimeout(function () {
            console.log(i);
        }, 1000);
    }
// 4 4 4 4
```

![image-20210626014118962](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145530.png)

![image-20210626014541703](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145531.png)

![image-20210626014600931](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145532.png)

![image-20210626014651906](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145533.png)

## 4-3 页面性能

![image-20210626014726536](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145534.png)

a 标签大部分默认打开DNS解析 但是在https中会禁止 所以要有强制打开

`<meta http-equiv='x-dns-prefetch-contorl' control='on'>`

### 异步加载

- 异步加载的方式
  - 动态脚本加载 动态添加节点撒 
  - defer
  - async
- 异步加载的区别
  - defer 是在HTML解析完之后才执行的，如果是多个，按照加载的顺序依次执行
  - async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

`defer`

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>defer</title>
    <script src="./14defer1.js" charset="utf-8" defer></script>
    <script src="./15defer2.js" charset="utf-8" defer></script>
</head>
<body>
<div class="">
    test
    <script type="text/javascript">
        console.log('write');
        document.write('<span>write</span>');
    </script>
    <script type="text/javascript">
        for (var i = 0; i < 200000; i++) {
            if (i % 20000 === 0) {
                console.log(i);
            }
        }
    </script>
</div>
</body>
</html>

```

![image-20210705170249395](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145535.png)

`ASYNC`

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>defer</title>
        <script src="./16async1.js" charset="utf-8" async></script>
        <script src="./17async.js" charset="utf-8" async></script>
</head>
<body>
<div class="">
    test
    <script type="text/javascript">
        console.log('write');
        document.write('<span>write</span>');
    </script>
    <script type="text/javascript">
        for (var i = 0; i < 200000; i++) {
            if (i % 20000 === 0) {
                console.log(i);
            }
        }
    </script>
</div>
</body>
</html>

```



![image-20210705170508546](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145536.png)

#### 查看二者区别

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>defer</title>
</head>
<body>
<div class="">
    test
    <script src="./18async3.js" async charset="utf-8" ></script>
    <script src="./16async1.js" charset="utf-8" async></script>
    <script src="./14defer1.js" charset="utf-8" defer></script>
    <script src="./15defer2.js" charset="utf-8" defer></script>
    <script src="./17async.js" charset="utf-8" async></script>
    <script type="text/javascript">
        console.log('write');
        document.write('<span>write</span>');
         for (var i = 0; i < 200000; i++) {
            if (i % 100000 === 0) {
                console.log(i);
            }
        }
    </script>
</div>
</body>
</html>

```

![image-20210705172138038](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706145537.png)

### 浏览器缓存

#### 缓存的分类

- 强缓存（问都不问直接用）
  - `Expires` Expires:Thu,21 Jan 2021 17:24:40 GMT 【·表示绝对时间 服务器的时间 判断本地与服务器的时间】
  - `Cache-Control`: max-age=2592000             【表示相对时间 】
  - 两个都有的情况下 以`Cache-Control`为主
- 协商缓存（还要问一下服务器的好）
  - Last-Modified下发的  If-Modified-Since以这个字段 请求的
  - `last-modified`: Mon, 21 Jun 2021 09:55:40 GMT
  - Etag If-None-Match 可以理解为hash值

## 4-4 错误监控

- 前端错误的分类
- 错误的捕获方式
- 上报错误的基本原理



### 前端错误的分类

- 即时运行错误：代码错误
- 资源加载错误

### 错误的捕获方式

#### 即时运行错误的捕获方式

- try 。。。 catch
- window.onerror

#### 资源加载错误—（记住他不会冒泡 所以window。onerror无法捕获）

- object.onerror
- performance.getEntries()      获取所有已加载资源的时长 间接来弄
- Error事件捕获  —–虽然说他没有冒泡 可他有捕获呀

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>错误监控</title>
    <script type="text/javascript">
        // 第三个参数 true捕获 false冒泡
      window.addEventListener('error', function (e) {
          console.log('捕获', e);
      }, true);
    </script>
  </head>
  <body>
    <script src="//badu.com/test.js" charset="utf-8"></script>
  </body>
</html>

```

#### 扩展：跨域的js运行错误可以捕获吗？错误提示是什么，应该怎么处理？

错误提示如下

![image-20210706150924739](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706150924.png)

解决方法：

- 在script标签添加`crossorigin`属性
- 设置js资源响应头`Access-Control-Allow-Origin:*` 或者域名

### 上报错误的基本原理

- 采用AJax通信的方式上报
- 利用Image对象上报（基本上都是用这种）

```js
    <script type="text/javascript">
      (new Image()).src = 'http://baidu.com/tesjk?r=tksjk';
    </script>
```



# 第5章 三面四面

## 5-1 业务能力

面试技巧

- 准备要充分
- 描述要演练
- 引导找时机
- 优势要发挥
- 回答要灵活

能力

- 业务能力
- 团队协作能力
- 事务推动能力
- 带人能力
- 其他能力

### 业务能力

![image-20210706152133142](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706152133.png)

一两句话描述业务

业绩能量化

技术方案

技术难点

有什么收获

![image-20210706152148905](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706152149.png)

## 5-2 团队协作能力与带人能力

![image-20210706152615500](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706152615.png)

![image-20210706153045689](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706153045.png)

![image-20210706153156198](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706153156.png)

![image-20210706153215742](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706153215.png)

# 第6章 课程终面

面试技巧

- 乐观积极
- 主动沟通
- 逻辑顺畅
- 上进有责任心
- 有主张，做事果断

内容分布

- 职业竞争力
- 职业规划

## 6-1 职业竞争力

![image-20210706153458636](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706153458.png)

## 6-2 职业规划

![image-20210706153756585](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706153756.png)

多说好话

多夸公司 多赞HR



# 第7章 课程总结

## 7-1 面试总结

![image-20210706154409102](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706154409.png)

![image-20210706154620287](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706154620.png)

![image-20210706154949460](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706154949.png)

![image-20210706155244603](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706155244.png)

![image-20210706155409326](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210706155409.png)