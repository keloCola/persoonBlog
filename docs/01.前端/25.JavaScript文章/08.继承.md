---
title: 继承
date: 2021-07-23 13:09:34
permalink: /pages/f516af/
categories:
  - 前端
  - JavaScript文章
tags:
  - 真
---
# 继承的几种实现方式

- class
- 构造函数方式继承
- 借助原型链实现继承
- 组合方式
- 组合方式优化1
- 组合方式优化2 最优解

<!-- more -->

## class方式实现继承

```js
// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}
// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}
//使用
Student.sayHi()
```

## 构造函数方式继承

- 构造函数继承中并不是真正的继承  不会继承`父类原型对象上的方法`
- 如果属性都在构造函数里 那没问题

` 继承的本质就是原型链`



```js
/*借助构造函数*/
function Parent1(){
    this.name = 'this is p1`s name'
}
Parent1.prototype.say = function (){
    console.log('this is p1.prototype`s say function')
}
function  Child1(){
//    改变构造函数的this指向 指向Child1的实例 实现继承
    Parent1.call(this) //apply也行 改变上下文
    this.type = 'this is C1`s type'
}
//实例化child1
console.log(new Child1())
```

![image-20210707154048372](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707154048.png)

## 借助原型链实现继承

```js
    /*
    * 借助原型链实现继承
    * */
    function Parent2() {
        this.name = 'Parent2'
    }

    function Child2() {
        this.type = 'child2'
    }

    //    重点！
    Child2.prototype = new Parent2()
    console.log(new Child2)
```

![image-20210709113306930](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210709113307.png)

缺点： 当实例化两个对象，s1 s2 = new child2(),由于是引用的，地址相同 ,改变s1 同时s2也会受影响

## 组合方式

```js
/*
    * 组合方式
    * */
    function Parent3() {
        this.name = 'Parent3'
        this.p = [1, 2, 3]
    }

    function Child3() {
        this.type = 'child3'
        //    构造函数继承
        Parent3.call(this)
    }

    //    原型链继承
    Child3.prototype = new Parent3()
    var s3 = new Child3()
    var s4 = new Child3()
    s3.p.push(4)
    console.log(s3, s4)
```

## 组合方式优化

```js
    function Child4() {
        this.type = 'child4'
        //    构造函数继承
        Parent4.call(this)
    }

    //    原型链继承
    Child4.prototype = Parent4.prototype
```

存在一个问题：`由于直接指定了parent4的prototype`，child4的构造函数就相当于也指向了parent4的构造函数，会出现无法判断归属，例如：

```js
var s5 = new Child4()
    var s6 = new Child4()
    s5.p.push(5)
    console.log(s5, s6)
    console.log(s5 instanceof Child4,s5 instanceof Parent4)//true true
    console.log(s5.constructor === Parent4  )//true
```

## 解决组合方式优化的问题

```js
    //    原型链继承
    Child5.prototype = Object.create(Parent5.prototype)
    //    覆盖一下 不然还是找到父类的
    Child5.prototype.constructor = Child5
```

## 综上 `这几种方式都要写出来 切记不要就只写最优的`

```js
    /*
* 组合方式 优化问题解决
* */
    function Parent5() {
        this.name = 'Parent5'
        this.p = [1, 2, 5]
    }

    function Child5() {
        this.type = 'child5'
        //    构造函数继承
        Parent5.call(this)
    }

    //    原型链继承
    Child5.prototype = Object.create(Parent5.prototype)
    //    覆盖一下 不然还是找到父类的
    Child5.prototype.constructor = Child5
```

