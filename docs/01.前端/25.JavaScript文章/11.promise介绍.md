---
title: promise介绍
date: 2021-07-23 13:35:12
permalink: /pages/bbfbac/
categories:
  - 前端
  - JavaScript文章
tags:
  - 真
---

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723134212.png)

<!-- more -->

# Promise的静态方法和实例方法

`注：这里有些公司会涉及手写Promise，大家可以去研究源码实现和手写一下。这个知识点很重要，高频考点中高频考点，大家一定要注意了啊！`

## 三种状态

- `pending` 待定
- `fulfilled/resolved` 兑现/解决/成功
- `rejected` 拒绝/失败
- Pending状态，不会触发then和catch
- Resolved状态，会触发后续的then回调函数
- Rejected状态，会触发后续的catch回调函数

## 状态改变

Promise对象的状态改变，只有两种可能：

- 从`pending`变为`fulfilled`
- 从`pending`变为`rejected`
- 过程不可逆

```
注意：这两种情况只要发生，状态就确定了，不会再变了。
```

## **静态方法**

### 1.Promise.resolve

`resolve` : 将`Promise`对象的状态从 `Pending(待定) `变为 `Fulfilled(成功)`

```js
new Promise(resolve => {
      resolve('hello 大海')
  }).then(res => {
    console.log(res)
  })
```

### 2.Promise.reject

`reject` : 将`Promise`对象的状态从 `Pending(待定) `变为 `Rejected(失败)`

```js
new Promise(reject => {
    reject('hello 大海')
}).then(res => {
  console.log(res)
})
```

### 3.Promise.all

- Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。
- 参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。
- **如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象**。
- 由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以`Promise.all` 可以处理不同类型的 Promise 对象
- 比如当数组里的`p1,p2,p3,p4`都执行完成时，页面才显示。
- 值得注意的是，返回的数组`结果顺序不会改变`，即使P2的返回要比P1的返回快，顺序依然是`p1,p2,p3,p4`
- `Promise.all`成功返回成功数组,失败返回失败数据,一但失败就不会继续往下走

```js
       let p1 = Promise.resolve('p1')
        let p2 = Promise.resolve('p2')
        let p3 = Promise.resolve('p3')
        let p4 = Promise.resolve('p4')
        Promise.all([p1, p2, p3, p4]).then(res => {
            console.log('成功', res); //返回数组
        }).catch(err => {
            console.log('失败', err);
        })

```

### 4.Promise.race

`Promise.race`是赛跑的意思，也就是说`Promise.race([p1, p2, p3,p4])`里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败

`Promise.race 生成并返回一个新的 Promise 对象`。

参数 promise 数组中的任何一个 Promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 Promise 对象的值进行 resolve 或者 reject。

```js
let p1 = Promise.resolve('p1')
let p2 = Promise.resolve('p2')
let p3 = Promise.reject('p3')
let p4 = Promise.resolve('p4')
Promise.race([p1, p2, p3, p4]).then(res => {
    console.log('成功', res); //返回数组
}).catch(err => {
    console.log('失败', err);
})
```

### 5.Promise.allSettled   //ES11的新特性

- 该方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。

- 当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。

  

```js
const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2];

Promise.allSettled(promises).
  then((results) => results.forEach((result) => console.log(result.status)));

```

![image-20210723141354337](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141354.png)

### 面试题

![image-20210514114212892](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707111125.png)

² 1 3

![image-20210514114222444](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707111126.png)

² 1 2 3

![image-20210514114232457](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707111127.png)

² 1 2 

## 实例方法(原型方法)

### 1.Promise.prototype.then

该方法可以接收两个回调函数作为参数，其中第二个回调函数是可选的。第一个回调函数是 `Promise` 对象的状态变为 `Resolved` 时调用，第二个回调函数是 `Promise` 对象的状态变为 `Rejected `时调用。

```js
var p1 = new Promise((resolve, reject) => {
  resolve('成功！');
  // or
  // reject(new Error("出错了！"));
});

p1.then(value => {
  console.log(value); // 成功！
}, reason => {
  console.error(reason); // 出错了！
});

```

### 2.Promise.prototype.catch

该方法返回一个Promise，并且只处理拒绝（rejected ）的情况。

```js
const p = new Promise((resolve, reject)=>{
    reject('失败了')
  }).catch(err=>{
      console.log(err);
  })

```

### 3.Promise.prototype.finally

该方法，无论上一个`promise `成败都会执行，且默认情况下会原样传递上一个 `promise` 的决议，但是`finally `对自身返回的 `promise` 的决议影响有限，它可以将上一个 `resolve` 改为 `reject`，也可以将上一个 `reject` 改为另一个 `reject`，但不能把上一个 `reject` 改为 `resolve`。 **默认情况**

```js
var p = Promise.resolve('ok')
.finally((res) => { 
  return res })
.then(value => {
  console.log('成功', value)
}, (err) => {
  console.log('失败', err)
});

```

**将上一个 `resolve` 改为 `reject`**

```js
var p = Promise.resolve('ok')
.finally(() => { 
  return Promise.reject('err') })
.then(value => {
  console.log('成功', value)
}, (err) => {
  console.log('失败', err)
});

```

### then和catch改变状态

- Then 正常返回resolved，里面有报错则返回rejected
- catch 正常返回resolved，里面有报错则返回rejected

## 面试官深挖的问题

### **then有几个参数，then第二个参数和catch的区别是什么？**

这里我面试官先问的是`then有几个参数`，我回答的是`1个`；接着面试官就问`then第二个参数和catch的区别是什么？`这时我就知道自己打错了，哎！所以后面这个问题我肯定也是答不出来的。

`then`方法可以接受两个回调函数作为参数。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。`then`方法返回的是一个实例（不是原来那个Promise实例）

**区别**

- **区别1** 最主要区别就是then中第一个函数里抛出的异常，它的第二个函数是捕获不到异常的，后面的catch可以捕获到（或者第二个then的第二个函数也可以捕获到）；
- **区别2**且then的第二个参数和catch捕获异常时会采取就近原则，当两者都存在时，则只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到；

### **用代码展示一下then第二个参数和catch的区别**

```js
const p = new Promise((resolve, reject)=>{
    resolve('对了')
  })
  p.then((res)=>{
    throw new Error('hello'); 
  },(err)=>{
      console.log(err,'第一个then捕获错误');
  }).catch((err1)=>{
    console.log(err1,'catch捕获错误');
  })

```

![image-20210723141428170](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141428.png) 

我们可以发现then中的第二个函数无法捕获到自身第一个函数抛出的异常，catch则可以捕获的得到 如果把catch删除，那么就会报错

```js
  const p = new Promise((resolve, reject)=>{
    resolve('成功了')
  })
  p.then((res)=>{
    throw new Error('hello'); 
  },(err)=>{
      console.log(err,'第一个then捕获错误');
  })

```

![image-20210723141458568](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141458.png)

也可以在继续使用then来捕获上一个then中抛出的错误

```js
const p = new Promise((resolve, reject)=>{
    resolve('成功了')
  })
  p.then((res)=>{
    throw new Error('hello'); 
  },(err)=>{
    console.log(err,'第一个then捕获错误');
  }).then((res)=>{},(err1)=>{
    console.log(err1,'第二个then捕获错误');
  })

```

![image-20210723141527784](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141527.png)

就近原则捕获异常，就是区别2

```js
const p = new Promise((resolve, reject)=>{
    resolve('成功了')
  })
  p.then((res)=>{
    throw new Error('hello'); 
  },(err)=>{
    console.log(err,'第一个then捕获错误');
  }).then((res)=>{},(err1)=>{
    console.log(err1,'第二个then捕获错误');
  }).catch((err2)=>{
    console.log(err2,'catch捕获错误');
  })

```

![image-20210723141601398](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141601.png)

### **Promise和async/await的区别**

- promise是ES6，async/await是ES7
- async/await相对于promise来讲，写法更加优雅
- reject状态：
  - 1）promise错误可以通过catch来捕捉，建议尾部捕获错误，
  - 2）async/await既可以用.then又可以用try-catch捕捉

### **Promise.all和 Promise.race的区别**

**区别**

- Promise.all成功返回成功数组,失败返回失败数据,一但失败就不会继续往下走
- Promise.race是赛跑的意思，也就是说Promise.race([p1, p2, p3,p4])里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败

#### **Promise.all**

```js
        let p1 = Promise.resolve('p1')
        let p2 = Promise.resolve('p2')
        let p3 = Promise.reject('p3')
        let p4 = Promise.resolve('p4')
        Promise.all([p1, p2, p3, p4]).then(res => {
            console.log('成功', res); //返回数组
        }).catch(err => {
            console.log('失败', err);
        })

```

![image-20210723141625215](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141625.png) 

#### **Promise.race**

```js
        let p1 = Promise.reject('p1')
        let p2 = Promise.resolve('p2')
        let p3 = Promise.reject('p3')
        let p4 = Promise.resolve('p4')
        Promise.race([p1, p2, p3, p4]).then(res => {
            console.log('成功', res); //返回数组
        }).catch(err => {
            console.log('失败', err);
        })
```

![image-20210723141647245](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141647.png)

### **Promise与setTimeout结合猜输出**

```js
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')
```

**分析**

- 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出start和end。
- setTimout作为一个宏任务被放入宏任务队列(下一个)
- Promise.then作为一个微任务被放入微任务队列
- 本次宏任务执行完，检查微任务，发现Promise.then，执行它
- 接下来进入下一个宏任务，发现setTimeout，执行。

![image-20210723141702765](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210723141702.png)