---
title: 104二叉树的最大深度
date: 2021-07-27 17:05:46
permalink: /pages/1172a6/
categories:
  - 算法
  - 算法-树
tags:
  - 
---
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。
<!-- more -->

示例：

```
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {

};
```



## 解题思路

::: details

- 求最大深度，考虑使用深度优先遍历
- 在深度优先遍历过程中，记录每一个节点所在的层级，找出最大的层级即可

:::

## 解题步骤

::: details

- 新建一个变量，记录最大深度
- 深度优先遍历整棵树，并记录每个节点的层级，同时不断刷新最大深度这个变量
- 遍历结束返回最大深度这个变量

:::

## 回顾之前知识

- 先访问根节点
- 对根节点的children挨个进行深度优先遍历

::: details 回顾一下深度优先遍历怎么写的

```js
const dfs = (root) => {//接收一个根节点
    console.log(root.val);//打印根节点
    root.children.forEach(dfs);//对子节点深度优先遍历
    // root.children.forEach((child)=>{dfs(child)})
};

dfs(tree);
```



:::

## 解题代码

::: details

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
 var maxDepth = function(root) {
  let res = 0//用来记录最大深度
   // 深度优先遍历
   const dfs = (n,level)=>{
     if(!n) return
     //在叶子节点中才操作
     if(!n.left&&!n.right){
      res= Math.max(res,level)
          }
     dfs(n.left,level+1)//遇到孩子 层级加1
     dfs(n.right,level+1)
   }
   dfs(root,1)
   return res
 };
```



:::

时间复杂度 O(n) n代表节点数

空间复杂度 O(n) 函数调用函数会有个隐形的调用堆栈 

最差情况n  n其实就是节点数 我们就看dfs()嵌套了多少次 最坏就是一边倒

最好是 logn 二叉树均匀分布的时候最好