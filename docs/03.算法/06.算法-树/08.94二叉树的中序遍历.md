---
title: 94二叉树的中序遍历
date: 2021-07-30 11:33:30
permalink: /pages/8a5a96/
categories:
  - 算法
  - 算法-树
tags:
  - 
---
给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)



```
输入：root = [1,null,2,3]
输出：[1,3,2]

输入：root = []
输出：[]
```
<!-- more -->
**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {

};
```





## 知识回顾

::: details

` 左 根 右 `---中序遍历

- 对根节点的`左`子树进行中序遍历
- 访问`根`节点
- 对根节点的`右`子树进行中序遍历

<img src="https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727143813.webp" alt="img" style="zoom:50%;" />

![1.gif](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210730100849.gif)

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727144654.png)



 中序遍历—非递归版

```js
/**
 * 中序遍历 非递归版
 */
const inorder = (root) => {
    if (!root) { return; }
    const stack = []//创建堆栈
    let p = root //指针p 指向根
    while (stack.length || p) {
        // 将所有的左节点放进栈中
        while (p) {
            stack.push(p)
            p = p.left//指针指向左孩子
        }
        const n = stack.pop() //推出栈顶元素
        console.log(n.val);//访问根节点
        p = n.right//访问当前出栈根节点的右孩子
    }
}

inorder(bt);
```

中序遍历—递归版

```js
/**
 * 中序遍历--递归版
 * @param {*} root 
 * @returns 
 */
const inorder = (root) => {
    if (!root) { return; }
    inorder(root.left);//左
    console.log(root.val);
    inorder(root.right);
};

inorder(bt);
```

:::

## 解题代码

::: details 递归版本

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 var inorderTraversal = function(root) {
   const res = []
  //  递归 参数为树的节点
   const rec = (n)=>{
     if(!n) return
     rec(n.left)
     res.push(n.val)
     rec(n.right)
   }
   rec(root)
   return res
};
```



:::

::: details 迭代版本

后进先出 栈

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  // 栈
  const res = []
  const stack = []
  let p = root
  while (stack.length || p) {
    while (p) {
      stack.push(p)
      p = p.left
    }
    // 出栈并访问
    const n = stack.pop()
    res.push(n.val)
    p = n.right//指向出栈了的右孩子上
  }

};
```

:::

时间复杂度O（N)

空间复杂度O(N)