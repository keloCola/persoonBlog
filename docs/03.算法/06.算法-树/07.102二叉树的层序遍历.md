---
title: 102二叉树的层序遍历
date: 2021-07-29 15:54:04
permalink: /pages/679f8c/
categories:
  - 算法
  - 算法-树
tags:
  - 
---
## 102. 二叉树的层序遍历


给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**

二叉树：`[3,9,20,null,null,15,7]`,

```
   3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```
<!-- more -->
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {

};
```



### 解题思路

::: details

- 层序遍历顺序就是`广度优先遍历`
- 不过在遍历的时候需要`记录当前节点所处的层级`方便将其添加到不同的数组中

:::

### 解题步骤

::: details

- 广度优先遍历二叉树
- 遍历过程中，记录每个节点的层级，并将其添加到不同的数组中

:::

### 知识回顾

::: details

`广度优先遍历`

<img src="https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727112848.png" alt="image-20210727112841307" style="zoom:50%;" />

- 新建一个队列，把根节点入队
- 把对头出队并访问
- 把对头的children挨个入队
- 重复第二第三步，直到队列为空

```js
const bfs = (root) => {
    const q = [root];//创建一个队列
    while (q.length > 0) {
        const n = q.shift();//将队头出队
        console.log(n.val);//访问对头
        n.children.forEach(child => {//挨个将对头的child入队
            q.push(child);
        });
    }
};

bfs(tree);
```



:::

### 解题代码

::: details

01.先保证root非空 `if(!root) return []`

02.做一下广度优先遍历

```js
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [root]//根节点入队
  //  广度优先遍历
  while (q.length) {
    // 出队
    const n = q.shift()
    // 访问根节点
    console.log(n.val);
    // 孩子有值就入队
    if (n.left) q.push(n.left)
    if (n.right) q.push(n.right)
  }
};
```

03.在遍历的过程中记录层级，我们将 root 改造成数组 [root,层级]

```js {3,4,11,12}
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [[root, 0]]//根节点入队
  //  广度优先遍历
  while (q.length) {
    // 出队
    const [n, leavel] = q.shift()
    // 访问根节点
    console.log(n.val, leavel);
    // 孩子有值就入队
    if (n.left) q.push([n.left, leavel + 1])
    if (n.right) q.push([n.right, leavel + 1])
  }
};
```

04,根据层级push到不同的数组中并返回

```js {4,11-17,22}
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [[root, 0]]//根节点入队
  const res = []//最终结果
  //  广度优先遍历
  while (q.length) {
    // 出队
    const [n, leavel] = q.shift()
    // 访问根节点
    // console.log(n.val, leavel);
    if (!res[leavel]) {
      //当前层级在结果中不存在 就推入整个数组
      res.push([n.val])
    } else {
      //当前层级已经存在数组，就在已存在的数组里追加
      res[leavel].push(n.val)
    }
    // 孩子有值就入队
    if (n.left) q.push([n.left, leavel + 1])
    if (n.right) q.push([n.right, leavel + 1])
  }
  return res
};
```



:::

:::details 解法2不需要记录每一层层级

01.基于广度优先遍历

```js
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [root]//根节点入队
  //  广度优先遍历
  while (q.length) {
    // 出队
    const n = q.shift()
    // 访问根节点
    console.log(n.val);
    // 孩子有值就入队
    if (n.left) q.push(n.left)
    if (n.right) q.push(n.right)
  }
};
```

02.确保每次推入或者推出都是同一层级的

```js {6,9-17}
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [root]//根节点入队
  //  广度优先遍历
  while (q.length) {
    let len = q.length
    // 确保while循环的都是同一层
    console.log('----------');
    while (len--) {
      // 出队
      const n = q.shift()
      // 访问根节点
      console.log(n.val);
      // 孩子有值就入队
      if (n.left) q.push(n.left)
      if (n.right) q.push(n.right)
    }
  }
}
```

![image-20210729145840935](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210729145841.png)

03.同一层的推到同一个数组里 并输出

```js {8,13,18,24}
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  if (!root) return []//确保非空
  const q = [root]//根节点入队
  const res = []
  //  广度优先遍历
  while (q.length) {
    let len = q.length
    //给结果先推一个空数组 用来放同一层的数据
    res.push([])
    // 确保while循环的都是同一层
    while (len--) {
      // 出队
      const n = q.shift()
      res[res.length - 1].push(n.val)
      // 孩子有值就入队
      if (n.left) q.push(n.left)
      if (n.right) q.push(n.right)
    }
  }
  return res
};
```



:::

时间复杂度 O(N) 广度优先
空间复杂度 线性增长的q 所以也是O(N)