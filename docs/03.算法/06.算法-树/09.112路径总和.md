---
title: 112路径总和
date: 2021-07-30 11:34:11
permalink: /pages/379a55/
categories:
  - 算法
  - 算法-树
tags:
  - 
---
给你二叉树的根节点 `root `和一个表示目标和的整数` targetSum `，判断该树中是否存在 `根节点到叶子节点 `的路径，这条路径上所有节点值相加等于目标和 `targetSum `。

`叶子节点` 是指没有子节点的节点。

**示例 1：**

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210730103755.jpeg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```
<!-- more -->
```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {

};
```



## 解题思路

::: details

- 在`深度优先遍历`的过程中，记录`当前路径的节点值`的`和`
- 在叶子节点处，判断当前路径的`节点值`是否等于`目标值`

:::

## 解题步骤

::: details

- 深度优先遍历二叉树，在叶子节点处，判断当前路径的节点值的和是否等于目标值，是就返回true
- 遍历结束，没有的话就返回false

:::

## 知识回顾

::: details 

- 深度优先比遍历
- 先访问根节点
- 对根节点的children挨个进行深度优先遍历

```js
const dfs = (root) => {//接收一个根节点
    console.log(root.val);//打印根节点
    root.children.forEach(dfs);//对子节点深度优先遍历
    // root.children.forEach((child)=>{dfs(child)})
};

dfs(tree);
```



:::

## 解题代码

::: details

01.判断空值 直接返回 false

02 深度优先遍历 dfs 

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root) return false
    //深度优先遍历 dfs
    const dfs = (n) =>{
        console.log(n.val)
        if(n.left) dfs(n.left)
        if(n.right) dfs(n.right)
    }
    dfs(root)
};
```

03.记录当前节点的节点值的和

```js {4,6,7,9}
var hasPathSum = function(root, targetSum) {
    if(!root) return false
    //深度优先遍历 dfs
    const dfs = (n,s) =>{
        console.log(n.val,s)
        if(n.left) dfs(n.left,s+n.left.val)
        if(n.right) dfs(n.right,s+n.right.val)
    }
    dfs(root,root.val)
};
```

04.判断当前叶子节点 并且当前节点值等于目标值 返回res

```js
var hasPathSum = function (root, targetSum) {
  if (!root) return false //传回空树 直接false
  let res = false
  //  写一个二叉树的深度优先遍历
  const dfs = (n, v) => {
    // 判断当前是否匹配
    if (!n.left && !n.right && v === targetSum) {
      res = true
    }
    if (n.left) dfs(n.left, v + n.left.val)
    if (n.right) dfs(n.right, v + n.right.val)
  }
  dfs(root, root.val)
  return res
};
```

时间复杂度：O(N) 遍历了所有的节点

空间复杂度：O(N) 递归-->函数调用堆栈-->n树的高度 最坏N，最好的是logN

:::