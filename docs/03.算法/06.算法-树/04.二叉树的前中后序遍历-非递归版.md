---
title: 二叉树的前中后序遍历-非递归版
date: 2021-07-27 17:05:22
permalink: /pages/6e395e/
categories:
  - 算法
  - 算法-树
tags:
  - 
---
![image-20210727161043851](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727161043.png)

## 先序遍历算法口诀

`根 左 右`

- 访问根节点
- 对根节点的左子树进行先序遍历
- 无左子树则对根节点的右子树进行先序遍历

<img src="https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727143448.webp" alt="img" style="zoom:50%;" />

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727144707.png)

::: details 先序遍历-非递归版

```js
/**
 * 先序遍历---非递归版本
 */
const preorder = (root) => {
    if (!root) { return }//根节点为空则直接返回
    const stack = [root] //创建函数调用堆栈 并将根节点放进堆栈
    while (stack.length) {
        const n = stack.pop()//弹出根节点
        console.log(n.val);//打印根节点
        if(n.right){stack.push(n.right)}//有右孩子则推进栈中 因为栈的特性所以先推右
        if(n.left){stack.push(n.left)}
    }
}

preorder(bt);
```

【root】

【R,L】

【R,L.r,L.l】L

【R,L.r】L L.l

【R】L L.l L.r

【R.r,R.l】L L.l L.r R

也就是

【19】

【 20 ， 10】19

【 20 】19 10

【】19 10 20 

<!-- ![先序遍历图解](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727145258.gif) -->

<!-- ![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727145258.gif) -->

:::

::: details 先序遍历 -递归版

```js
/**
 * 先序遍历-递归版
 */
const preorder = (root)=>{
    if(!root){return}//根节点为空则直接返回
    console.log(root.val);//访问根节点
    preorder(root.left)//对根节点的左子树进行先序遍历
    preorder(root.right)//对根节点的右子树进行先序遍历

}
```

:::





## 中序遍历算法口诀

` 左 根 右 `

- 对根节点的`左`子树进行中序遍历
- 访问`根`节点
- 对根节点的`右`子树进行中序遍历

<img src="https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727143813.webp" alt="img" style="zoom:50%;" />

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727144654.png)



:::  details  中序遍历—非递归版

```js
/**
 * 中序遍历 非递归版
 */
const inorder = (root) => {
    if (!root) { return; }
    const stack = []//创建堆栈
    let p = root //指针p 指向根
    while (stack.length || p) {
        // 将所有的左节点放进栈中
        while (p) {
            stack.push(p)
            p = p.left//指针指向左孩子
        }
        const n = stack.pop() //推出栈顶元素
        console.log(n.val);//访问根节点
        p = n.right//访问当前出栈根节点的右孩子
    }
}

inorder(bt);
```



:::

:::  details  中序遍历—递归版

```js
/**
 * 中序遍历--递归版
 * @param {*} root 
 * @returns 
 */
const inorder = (root) => {
    if (!root) { return; }
    inorder(root.left);//左
    console.log(root.val);
    inorder(root.right);
};

inorder(bt);
```

<!-- ![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727150618.gif) -->

:::



## 后序遍历

·`左 右 根`

- 对根节点的`左`子树进行后序遍历
- 对根节点的`右`子树进行后序遍历
- 访问`根`节点

<img src="https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727143406.webp" alt="img" style="zoom:50%;" />

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727144639.png)



::: details 后序遍历—非递归版

`左右根` 给他倒过来 变成 `根右左`

将打印操作 变成入栈操作

复用先序遍历的逻辑 实现逆的逻辑

再利用栈先进后出的特性

将操作倒过来访问 获得我们想要的 这里涉及两个栈



```js
const postorder = (root)=>{
    if(!root) return 
    const stack =[root]//用于先序遍历的栈
    const outputStack = []//用于倒置的栈
    while(stack.lenth){
        const n = stack.pop()//
        outputStack.push(n)//推入倒置堆栈中
        if(n.left) stack.push(n.left)
        if(n.right) stack.push(n.right)
    }
    while(outputStack.lenth){
        const p = outputStack.pop()
        console.log(p.val);
    }
}
postorder(bt);

```

<!-- ![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727152858.gif) -->

:::



::: details 后序遍历—递归版

```js
const postorder = (root) => {
    if (!root) { return; }
    postorder(root.left);//左
    postorder(root.right);//右
    console.log(root.val);//打印根
};
postorder(bt);

```

:::

## 遍历总结

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210727144820.png)
