---
title: 慕课算法课程
date: 2021-07-19 15:53:35
permalink: /pages/703589/
categories:
  - 算法
tags:
  - 
---
`javaScript数据结构与算法`

[toc]

# 第1章简介

## 课程目标

- 掌握数据结构和算法的理论知识
- 补齐求职面试中的算法短板
- 梳理前端和算法结合点，不再纸上谈兵，将算法用于实战

## 课程三部曲

- 理论：数据结构和算法的特点，应用场景等
- 重点关注   数据结构与算法的特点，应用场景，JS实现，空间、时间复杂度

![image-20210603104359126](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155407.png)

- 刷题：做一些算法题，推荐LeetCode
  -  刷题顺序，按照类型刷题，集中训练
  -  重点关注：通用套路，时间、空间复杂度分析和优化
- 实战：在工作中与数据结构/算法打交道

##  数据结构与算法是什么

![image-20210603104640143](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155408.png)

## 数据结构与算法的关系

- 程序= 数据结构+算法
- 数据结构为算法提供服务，算法围绕数据结构操作

##  将要学习的数据结构

- 栈，队列，链表
- 集合、字典
- 树、堆、图
- 链表：遍历链表、删除链表节点
- 树、图：广度/深度优先遍历
- 数组：冒泡/选择/插入/归并/快速排序/顺序/二分搜索



# 第2章 时间/空间复杂度计算

## 时间复杂度

- 一个函数，用O
- 定性

![image-20210603104933947](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155409.png)

```js
let i = p
i +=1
//O(1)
```

```js
for(let i = 0;i<n;i++){
    console.log(i)//执行n次
}
//O(n)
```

```js
let i = 0
i +=1
for(let j = 0;j<n;j++){
    console.log(j)
}
//O(1)+O(n)=O(n)
```

```js
for(let i = 0 ; i < n ; i++){
    for(let j = 0 ; j < n ; J++){
        console.log(j)
    }
}
//O(n) * O(n) = O(n^2)
```

```js
let i = 1
while(i<n){
    console.log(i)
    i*=2
}

//以2为底  log
//O(logN)
```

##  空间复杂度

- 一个函数，用大O标识，比如O(1)、O(n)、O(n^2)…
- 算法在运行过程中临时占用存储空间大小的量度

```js
let i = 0
i+=1
//O(1)
```

```js
const list = []
for(let i = 0;i<n:i++){
list.push(i)
}
// O(n)
```

```js
const matrix = []
for(let i = 0;i<n;i++){
    matrix.push([])
    for(let j=0;j<n;j++){
        matrix[i].push(j)
    }
}
//矩阵 O(n^2)
```

# 第3章数据结构之“栈”

## 栈简介

- 后进先出
- javaScript中没有栈，但是可以用Array实现栈的所有功能

```js
const stack = [];
stack.push(1);//[1]
stack.push(2);//[1,2]
const item1 = stack.pop();//[1] item1=2
const item2 = stack.pop();//[] item2=1
```



## 什么场景下用栈

- 需要`后进先出`的场景
- 比如： 十进制转二进制、判断字符串的括号是否有效、函数调用堆栈

## 场景一：十进制转二进制

![image-20210603150209772](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155410.png)

## 场景二：有序的括号

![image-20210603150308250](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155411.png)

##  函数调用堆栈

![image-20210603150403093](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155412.png)

## 题号：20 leetcode 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {


};

```

### 解题思路—–栈

- 对于没有闭合的左括号而言，越靠后的左括号对应的有括号约靠前
- 满足后进先出，考虑用栈

### 解题步骤

- 建立一个栈
- 扫描字符串
- 遇到`左括号`就`入栈`,
- 遇到栈顶括号类型`匹配的右括号`就`出栈`
- 遇到不匹配的直接判定不合法
- 最后栈空了就合法 否则不合法 length===0

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    //字符串不是偶数的 直接不合法
    if(s.length%2===1){return false}
    //建一个栈
    const stack = []
    // 扫描字符串
    for(let i =0 ;i<s.length;i++){
        const c = s[i]
        // 遇见左括号 入栈
        if((c==='(')||(c==="[")||(c==="{")){
            stack.push(c)
        }else{
            // 获取栈顶
            const top = stack[stack.length-1]
            // 判断栈顶是否匹配
            if(
                (top==='('&&c===')')||
                (top==='{'&&c==='}')||
                (top==='['&&c===']')
            ){
                // 匹配就出栈              
                stack.pop()
            }else{
                return false
            }
        }
    }
    // 判断栈空
    return stack.length===0

};
```

## 前端与栈：JS中的函数调用堆栈

```js
const func1 = () => {
    func2();
};
const func2 = () => {
    func3();
};
const func3 = () => {};

func1();

```

![image-20210603153303133](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155413.png)

![image-20210603153309148](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155414.png)

##  栈-章节总结

- 栈是一个后进先出的数据结构
- JavaScript中没有栈，我们用array实现栈所有功能
- 常用操作：push，pop，stack[stack.length-1]



# 第4章 数据结构之“队列”

## 队列简介 

- `先进先出`的数据结构
- enqueue 入队
- back
- dequeue 出队
- front
- javaScript没有队列，但是可以用`array`实现队列的所有功能
- array中我们用 `push` 入队 `shift`出队

![image-20210603162022464](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155415.png)

```js
const queue = [];
queue.push(1);//入队[1]
queue.push(2);//入队[1,2]
const item1 = queue.shift();//出队 item1；1   [2]
const item2 = queue.shift();//出队 item2；2   []

```

## 什么场景用队列

- 需要`先进先出
- 比如：食堂排队打饭，js异步中的任务队列，计算最近请求次数

## 场景：食堂打饭

- 先进先出，保证有序

## 场景：JS异步中的任务队列

![image-20210603162619588](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155416.png)



- JS是单线程，无法同时处理异步中的并发问题
- 使用任务队列先后处理`异步任务`

## 场景：计算最近请求次数

- 输入一个数组表示发出请求的时刻

- 输出当前时刻下 3000毫秒内的请求次数

![image-20210603162903147](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155417.png)

## LeetCode：933. 最近的请求次数

写一个` RecentCounter` 类来计算特定时间范围内最近的请求。

请你实现 `RecentCounter `类：

- RecentCounter() 初始化计数器，请求数为 0 。

- int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。

`保证` 每次对 ping 的调用都使用比之前更大的 t 值。

### 示例：

```js
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

```js
var RecentCounter = function() {

};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {

};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
```

### 解题思路

![image-20210603163712753](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155418.png)

### 解题步骤

![image-20210603163737504](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155419.png)

```js
var RecentCounter = function() {//类构造函数
  this.q=[]//将数组挂载在构造函数this中 保证类方法调用的队列为同一个
};

/** 
* @param {number} t
* @return {number}
*/
RecentCounter.prototype.ping = function(t) {//类方法 ping
  this.q.push(t)//t 先进站
    //判断对头在不在范围内 不在就踢出去
  while(this.q[0]<t-3000){
      this.q.shift();//出队
  }
  return this.q.length
};

/**
* Your RecentCounter object will be instantiated and called as such:
* var obj = new RecentCounter()
* var param_1 = obj.ping(t)
*/

```

## 前端与队列：JS 异步中的任务队列 

```js
settimeout(()=>{
    console.log(1)
},0)
console.log(2)

// 2 1
```

![image-20210603164526331](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719155420.png)

## 队列-章节总结

- 队列是一个先进先出的数据结构
- JavaScript中没有队列，但可以用Array实现队列的所有功能
- 队列常用操作：push、shift、queue[0]

# 第5章 数据结构之“链表”

## 链表简介

- 多个元素组成的列表

- 元素存储不连续，用next指针连在一起
- ![image-20210616200946203](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160243.png)

## 数组VS链表

- 数组：增删非首尾元素时往往需要移动元素
- 链表：增删非首尾元素，不需要移动元素，只需要更改next的指向即可

##  JS中的链表

- JavaScript中没有链表
- 可以用`Object`模拟链表

![image-20210616201030137](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160244.png)

```js
const a = { val: 'a' };
const b = { val: 'b' };
const c = { val: 'c' };
const d = { val: 'd' };
a.next = b;
b.next = c;
c.next = d;
// 遍历链表
let p = a;//务必记得要搞这么一下
while (p) {
    console.log(p.val);
    p = p.next;
}

```

```js
// 插入
const e = { val: 'e' };
c.next = e;
e.next = d;

```

```js
// 删除
c.next = d;

```

##   LeetCode：237.删除链表中的节点 

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

![image-20210616201622642](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160245.png)

示例 1：

输入：head = [4,5,1,9], node = 5

输出：[4,1,9]

解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

```js
var deleteNode = function(node) {
 
};

```

![image-20210616201653449](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160246.png)

![image-20210616201658765](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160247.png)

```js
var deleteNode = function(node) {
  node.val= node.next.val;
  node.next=node.next.next
};

```

## LeetCode：206.反转链表

反转一个单链表。

**示例**

**输入** 1->2->3->4->5->NULL

**输出** 5->4->3->2->1->NULL

```js
var reverseList = function(head) {
  
};

```

![image-20210705102904784](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160248.png)

![image-20210705102910845](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160249.png)

```js
var reverseList = function(head) {
  let p1 = head
  let p2 = null
  while(p1){
      const tmp = p1.next
      p1.next=p2
      p2= p1
      p1=tmp
  }
  return p2
};

```

时间复杂度 O（n）

空间复杂度O(1)

## LeetCode：2. 两数相加 

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![image-20210705103010125](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160250.png)

```js
var addTwoNumbers = function(l1, l2) {

};

```

![image-20210705103026282](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160251.png)

![image-20210705103031562](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160252.png)

```js
var addTwoNumbers = function(l1, l2) {
  const l3 = new ListNode(0)
  let p1 = l1
  let p2 = l2
  let p3 = l3
  let carray= 0
  while(p1||p2){
      const v1 = p1?p1.val:0
       const v2 = p2?p2.val:0
       const val = v1 + v2 +carray
      carray = Math.floor(val / 10) 
       p3.next = new ListNode(val%10)//取个位数
       if(p1) p1= p1.next
       if(p2) p2= p2.next
       p3= p3.next

  }
  if(carray){
      p3.next = new ListNode(carray)
  }
  return l3.next
};

```

时间复杂度 空间复杂度 都为O(n)

## LeetCode：83. 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

![image-20210705103109539](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160253.png)

```js
var deleteDuplicates = function(head) {
  
  };

```

![image-20210705103125628](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160254.png)

![image-20210705103130419](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160255.png)

```js
var deleteDuplicates = function(head) {
  let p = head;
    while (p && p.next) {
      if (p.val === p.next.val) {
        p.next = p.next.next
      }else{
          p = p.next
      }
    }
    return head
  };

```

## LeetCode：141. 环形链表

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

![image-20210705103214471](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160256.png)

```js
var hasCycle = function(head) {


};

```

![image-20210705103229000](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160257.png)

![image-20210705103233534](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160258.png)

```js
var hasCycle = function(head) {
  let  p1 = head //慢的指针
  let p2 =head //快的指针
  while(p1 && p2 && p2.next){
      p1 = p1.next
      p2 = p2.next.next
      if(p1 === p2){
          return true
      }
  }
  return false
};

```

## 前端与链表：JS 中的原型链

- 原型链的本质是链表
- 原型链上的节点是各种原型对象，比如` Function.prototype ` `Object.prototype`
- 原型链通过`__proto__`属性链接各种原型对象
- obj —>Object.prototype –>null
- func —> Function.prototype —> Object.prototype —> null
- arr  —> Array.prototypr  —>  Object.prototype —> null
- 如果A沿着原型链能找到B.prototype,那么A instanceof B 为 true
- 如果在A对象上没有找到X属性，那么会沿着原型链找X属性

##   instanceof 的原理 并用代码实现

- 知识点：如果A沿着原型链能找到B.prototype,那么A instanceof B 为 true

- 解法：遍历A的原型链，如果找到B.prototype 返回true 否则返回false

```js
const instanceOf = (A,B)=>{
  let p = A
  while(p){
    if(p===B.prototype){
      return true
    }
    p= p.__proto__
  }
  return false
}

```

##  前端与链表：使用链表指针获取 JSON 的节点值 

```js
const json = {
    a: { b: { c: 1 } },
    d: { e: 2 },
};

const path = ['a', 'b', 'c'];

let p = json;
path.forEach((k) => {
    p

```



## 链表-章节总结

![image-20210705103648261](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160259.png)

![image-20210705103653362](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210719160300.png)



