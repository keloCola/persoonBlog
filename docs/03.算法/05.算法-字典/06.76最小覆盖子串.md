---
title: 76最小覆盖子串
date: 2021-07-26 17:38:27
permalink: /pages/c2136f/
categories:
  - 算法
  - 算法-字典
tags:
  - 
---
#  LeetCode：76. 最小覆盖子串 

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
<!-- more -->
**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例3**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。
```

::: details 提示：

- `1 <= s.length, t.length <= 105`
- `s` 和 `t` 由英文字母组成

:::

**进阶：**你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {

};
```



## 解题思路

::: details

- 先找出所有的包含`T`的子串
- 找出长度最小的那个子串，返回即可

:::

## 解题步骤

::: details

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

- 用双指针维护一个滑动窗口
- 移动右指针，找到包含T的子串，移动左指针，尽量减少包含T的子串的长度
- 循环上述过程，找到包含 T 的最小子串

<img src = ‘https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif' />



![img](https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif)

[力扣官网解析](https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/)

:::

## 解题代码

::: details

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
  let l = 0 //左指针
  let r = 0 //右指针
  // 初始化一个字典
  const need = new Map()
  // 设置需要的 字母 和个数
  for (let c of t) {
    need.set(c, need.has(c) ? need.get(c) + 1 : 1)
  }
  let needType = need.size//需要的类型 等于 需要字典的长度
  let res = '' //用来记录最小的符合条件的字符串
  // 遍历 移动右指针
  while (r < s.length) {
    const c = s[r]//获取当前遍历的字符串值
    // 判断当前值在需求中是否存在
    if (need.has(c)) {
      // 存在 需求对应的值 - 1
      need.set(c, need.get(c) - 1)
      // 需要的数量为0  将needType -1 
      if (need.get(c) === 0) needType -= 1
    }
    // needType 为0 即滑动窗口都有的时候回，尽量减少左指针
    while (needType === 0) {
      const newRes = s.substring(l, r + 1)//左闭右开 故右+1
      if (!res || newRes.length < res.length) res = newRes
      const c2 = s[l]//获取左指针当前位置
      // 如果当前左指针对应的值 是存在于 need中 
      // 移动左指针 相对应的 need 里面要增加
      if (need.has(c2)) {
        need.set(c2, need.get(c2) + 1)
        // 当 左指针对应的needType为1 的时候 说明 滑动窗口里面包含的不够了
        if (need.get(c2) === 1) {
          needType += 1
        }
      }
      // 移动左指针
      l += 1
    }
    r += 1
  }
  return res

};
```

:::

时间复杂度：O(m+n), m 是 t 的长度，n 是 s 的长度

空间复杂度：O(k) ， k 是 t 里面不同字母的个数