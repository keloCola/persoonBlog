---
title: 2021面经
date: 2021-07-15 17:36:13
permalink: /pages/7e26b3/
categories:
  - 前端
  - JavaScript文章
tags:
  - 面经
  - 一面
  - 二面
---
# HTML+浏览器相关

## []   状态码 304怎么做 

客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。

对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。
因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。

![image-20210617103613092](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173335.png)

##  []   Cache-control有几个属性

在请求中使用Cache-Control 时，它可选的值有：

![image-20210617103444444](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173336.png)

在响应中使用Cache-Control 时，它可选的值有：

![image-20210617103455435](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173337.png)

1. 缓存开关是： pragma， cache-control。
2. 缓存校验有：Expires，Last-Modified，etag。

## []   tcp与udp区别

### TCP和UDP的比较

#### 1. 对比

|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | :------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

#### 2. 总结

- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP

### TCP/IP网络模型

计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。

TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。

TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。

- 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。
- 网络层：负责路由以及把分组报文发送给目标网络或主机。
- 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。
- 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。

![image-20210617103713150](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173338.png)

在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议----TCP 和 UDP。

### UDP用户数据报协议

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于`处理数据包`，是一种`无连接的协议`。在OSI模型中，在第四层——`传输层`，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

它有以下几个特点：

#### 1. 面向无连接

首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

#### 2. 有单播，多播，广播的功能

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

#### 3. UDP是面向报文的

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

#### 4. 不可靠性

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173339.gif)

从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并`不在意数据有无安全完整到达`。

#### 5. 头部开销小，传输数据报文时是很高效的。

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173340.png)

UDP 头部包含了以下几个数据：

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

### TCP传输控制协议

当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。

TCP协议全称是`传输控制协议`是一种`面向连接的、可靠的、基于字节流的传输层通信协议`，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。

#### 1. TCP连接过程

如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173341.png)

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173342.gif)

#### 2. TCP断开链接

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173343.png)

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

**第一次握手**

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

**第四次握手**

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

#### 3. TCP协议的特点

- `面向连接`

  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

- `仅支持单播传输`

每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。

- `面向字节流`

TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

- `可靠传输`

  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

- `提供拥塞控制`

当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞

- `TCP提供全双工通信`

TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

## []   tcp如何保证数据稳定？

三次握手，滑动窗口，慢开始，拥塞控制，超时重传，快重传

能够保证TCP协议可靠的算法有**检验和**，**连接管理机制**，**ACK应答机制**，**快速重传和超时重传机制**，**滑动窗口机制**，**拥塞控制机制**，这些机制共同保证TCP协议的可靠性

### 检验和：

TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验范围包括TCP首部及数据部分，但是UDP的检验和字段为可选的，而TCP中是必须有的。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确（UDP中为0是正确），否则存在错误。可以保证接收方能判断当前报文是否属于自己要接受的报文，如果为0，那就是，不为0，则不是，丢弃此报文。抽象些来说就像是取快递，你的电话姓名和快递上的信息一致，你才能确定这是你的快递，才会去取，不会错拿别人的快递。

### 序列号：

TCP 对每个报文进行编号，这些编号就是序列号。而序列号有多种作用
a：保证可靠性，当接收到的数据失序时，就能立马知道
b：去除重复的报文，数据传输过程中的确认应答，重发控制，重复控制等功能都要依靠序列号来实先。
c：提高效率，可以实现多次发送，一次确认。

### ACK应答机制：

发送的每一条消息，都需要对方发送一条消息来回复消息是否被收到。

主要实现是TCP的首部来控制，当ACK =1 时ack才有效，ack等于期望下一个传输过来的序号，也就是上一次接收消息的序号+1。这样就可以保证消息能被确认接收。（三次握手和四次挥手都在用这个机制）

### 连接管理机制：

三次握手建立连接与四次挥手断开连接，保证了TCP的全双工工作。

### 快重传和超时重传：

保证了数据能够不丢失的传输数据。（注意：超时重传机制和快重传机制，同时存在。谁先检验到报文失序，谁就生效。）

### 快重传：

发送方连续收到3个接收方发送的同一个ack时，此时快速重传ack序号以及其之后的所有数据报。

![image-20210617104523656](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173344.png)

### 超时重传：

当发送方发送了数据给接收方，当时超过了约定的时间（RTO）也没有接收到确认消息，此时重传此报文。（Tips：RTO也就是重传超时时间，这个时间由TCP的自适应算法生成）

![image-20210617104538688](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173345.png)

### 滑动窗口：

滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。数据的发送方和接收方都有滑动窗口，对于发送方来说，窗口内就是可以发送的报文，当窗口的前沿紧挨的报文发送并且确认时，窗口向后移动。而窗口的后沿可以向前移动，当接收方处理不了那么多的报文时，就会发送消息告诉发送方，此时滑动窗口就需要缩小，所以后沿前移。但是TCP非常不建议窗口后沿前移。

说到滑动窗口，就不得不梳理一下消息发送的过程中的缓存机制:

![image-20210617104547650](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173346.png)

 

发送方和接收方的滑动窗口工作流程：

![image-20210617104611626](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173347.png)

内部细节图 A为发送方 B为接收方

![image-20210617104630447](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173348.png)

伴随着效率的提升，也会有问题产生，如果消息没被确认怎么办如图所示，假如31，32，33，34，报文发送了，32，33，34都被确认了，31没被确认怎么办呢？这时就重新发送31，并且31之后的数据报全部重新发送。 

![image-20210617104657440](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173349.png)

在图中我们还会发现窗口的前沿和后沿会移动，窗口前沿和后沿都向后移动，意味着前沿紧挨的报文发送并被确认，而后沿的前移意味着，接收端处理那么多消息，请缩小窗口的大小。
所以解决了发送的数据过多，导致接收端无法正常接收的异常。 

拥塞控制：拥塞控制使得宏观网络中的资源能够合理的应用。实现的算法有四个，慢开始，拥塞避免，快速回复，和快速重传.

1.慢开始指一开始发送报文时，不清楚网络中的情况，试探性的发送1cwnd(拥塞窗口)的数据量。

2.如果没有到ssthresh(慢开始门限值)，则以指数形式增长，一直到门限值；

3.当到达门限值时，此时采用拥塞避免算法让拥塞窗口缓慢增长，即每经过一个RTT（往返时间）就把发送方的拥塞窗口+1，不能是指数性增长了，一直到发生网络拥塞为止。 

4.当发生网络拥塞时，把ssthresh的值设置为出现拥塞时发送窗口大小的一半，然后把拥塞窗口设置为1，再次执行慢开始算法。

5.在发送方知道只是丢失了个别的报文段时，采用快恢复算法，将门限值设置成拥塞窗口大小的一半，并将拥塞窗口设置为当前门限值，并执行拥塞避免算法。

6.当发送方一连收到3个对同一个报文段的重复确认时，采用快速重传算法，立即进行重传，这样就不会出现超时，可以使整个网络的吞吐量提高约20%。

##   cdn原理，cdn回源怎么做

CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽量避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。经过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统可以实时地根据网络流量和各节点的链接、负载情况以及到用户的距离和响应时间等综合信息将用户的请求从新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的情况，提升用户访问网站的响应速度

##    从浏览器输入 URL 到整个页面显示的整个过程？过程尽可能的详细？

主要把DNS解析，HTTP 三次握手，和浏览器的渲染过程详细讲了一下，面试官很满意

## []   浏览器内存泄露的场景及如何解决？

### **什么是内存泄露？**

已经不再使用的内存未能被程序释放，叫内存泄露(memory leak)。

**内存泄露会带来什么样的后果？**

内存泄露会因为减少可用内存数量从而降低计算机性能，严重的可能导致设备停止正常工作，或者应用程序崩溃。

### **什么情况下出现内存泄漏？**

首先了解一下垃圾回收：垃圾回收（英语：Garbage Collection，缩写为GC）在计算器科学中是一种自动的[存储器管理](https://zh.wikipedia.org/wiki/記憶體管理)机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。

**当一块内存不再用到，但是垃圾回收机制又无法释放这块内存的时候，就导致内存泄漏。**

### **出现内存泄露的的几种常见情况：**

#### **1、全局变量**

由于JavaScript对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是window对象。变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。

```javascript
(1). 未声明变量：
     a = '我是未声明的变量a，我缓存了数据，如果数据足够大的话，就会内存泄漏'

(2). 通过this也会创建全局变量，当在全局作用域中调用一个函数，这个函数内部用this.var的方式创建了一个变量，
     此时this指向的是全局对象(window)，而不是'undefined'如：

     function leak() {
         this.variable = "potential accidental global"
     }
     leak()
```

#### **2、闭包(closures): **

**js函数内可以直接读取全局变量，但是函数外不能读取函数内的局部变量。这时候在函数f1内再声明一个函数f2调用局部变量，**

   **然后返回函数f2，****在f1的外部声明一个变量result赋值为f1，再调用result，就是一个闭包的例子。**

```
    function f1(){
　　　　var n = 999;
　　　　function f2(){
　　　　　　alert(n); 
　　　　}
　　　　return f2;
　　}

　　var result = f1();
　　result(); // 999
```

```
    闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。
```

#### 3、事件监听(EventListener)

   对同一个事件重复监听，但是忘记移除，会导致内存泄露。

#### 4、其他原因

   console.log打印的对象不能被垃圾回收，可能会导致内存泄露。
   setInterval也可能会导致内存泄露。

### **前端如何检查内存泄露？**

(1).使用Chrome的开发者工具profiles来进行快照对比。

(2).如果是在Node环境下，可以用Node提供的process.memoryUsage()方法来检查内存泄露:

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173350.png)

**rss** (resident set size) : 所有内存占用，包括指令区和堆栈。

**heapTotal** : "堆"占用的内存，包括用到的和未用到的。

**heapUsed** : 用到的堆。

**external** : V8引擎内部C++对象占用的内存。

判断内存泄露以**heapUsed为准。**

### **如何处理内存泄漏？**

变量导致的内存泄露，将变量清除 a = null 即可。

事件监听导致的内存泄露，监听后移除即可。









# css

## flex布局

## grid布局

## 移动端布局，移动端适配

# js

## promise源码介绍

## 01 CORS [通信](https://wangdoc.com/javascript/bom/cors.html)

CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出`XMLHttpRequest`请求，从而克服了 AJAX 只能同源使用的限制。

### 简介

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。

### 两种请求

CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

（1）请求方法是以下三种方法之一。

> - HEAD
> - GET
> - POST

（2）HTTP 的头信息不超出以下几种字段。

> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。

这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。

### 简单请求

#### 基本流程

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

```
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

```
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

上面的头信息之中，有三个与 CORS 请求相关的字段，都以`Access-Control-`开头。

**（1）`Access-Control-Allow-Origin`**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）`Access-Control-Allow-Credentials`**

该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为`true`，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送 Cookie，不发送该字段即可。

**（3）`Access-Control-Expose-Headers`**

该字段可选。CORS 请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个服务器返回的基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

#### withCredentials 属性

上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定`Access-Control-Allow-Credentials`字段，告诉浏览器可以发送 Cookie。

```
Access-Control-Allow-Credentials: true
```

同时，开发者必须在 AJAX 请求中打开`withCredentials`属性。

```
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。

但是，有的浏览器默认将`withCredentials`属性设为`true`。这导致如果省略`withCredentials`设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭`withCredentials`。

```
xhr.withCredentials = false;
```

需要注意的是，如果服务器要求浏览器发送 Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的`document.cookie`也无法读取服务器域名下的 Cookie。

### 非简单请求

#### 预检请求

非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量`DELETE`和`PUT`请求，这些传统的表单不可能跨域发出的请求。

下面是一段浏览器的 JavaScript 脚本。

```
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP 请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。

```
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

“预检”请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，“预检”请求的头信息包括两个特殊字段。

**（1）`Access-Control-Request-Method`**

该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是`PUT`。

**（2）`Access-Control-Request-Headers`**

该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 预检请求的回应

服务器收到“预检”请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的 HTTP 回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

```
Access-Control-Allow-Origin: *
```

如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。

```
OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
```

上面的服务器回应，`Access-Control-Allow-Origin`字段明确不包括发出请求的`http://api.bob.com`。

这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

```
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）`Access-Control-Allow-Methods`**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。

**（2）`Access-Control-Allow-Headers`**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。

**（3）`Access-Control-Allow-Credentials`**

该字段与简单请求时的含义相同。

**（4）`Access-Control-Max-Age`**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是“预检”请求之后，浏览器的正常 CORS 请求。

```
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

```
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。

### 与 JSONP 的比较

CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持`GET`请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

## 02 options预检请求作用

### 作用

在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。

### options请求具备以下特性：

![image-20210617100935793](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173351.png)
所以，options请求是用于请求服务器对于某些接口等资源的支持情况的。

### 问题

前端向后端发起请求，后端接收不到请求头信息。原因就是在预请求中进行查找了，当然没有结果。

### 解决方案

在过滤器的方法体开头加入以下代码：

```js
// OPTIONS预请求放行
if (request.getMethod().equals("OPTIONS")) {
    chain.doFilter(request, response);
    return;
}

```



### 字符串的自动缩略

```js
white-space: nowrap;
text-overflow: ellipsis;
overflow: hidden;

```



## 避免二次请求，once函数



## 后台频繁请求有压力，有什么方法可以避免？

1.防抖，限制 

2.本地缓存或sessionStorage



## 函数式编程与面向对象的区别，优缺点

## 闭包是函数式编程吗？

## bind、apply、call 的区别？

## 手写实现apply

# vue

## eventBus介绍,使用业务场景，和vuex对比，优缺点，对eventBus熟悉吗



# react



# webpack



# 项目相关

## 扫码登录怎么做，手机端和PC端都要建立长连接吗

## sso单点登录

## 实现累充充值接口的思路，如何保证`实时性`

## 文件断点续传思路

# 其他

## 进程与线程区别，线程间通信方式

## 流的概念，node stream流

## osi7层模型

![7层](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210707173352.png)

网络中的七层协议为：`应用层、表示层、会话层、传输层、网络层、数据链路层、物理层`。那么介绍一下在网络七层协议中传输数据时的工作原理是：在数据的实际传输中，发送方将数据送到自己的应用层，加上该层的控制信息后传给表示层；表示层如法炮制，再将数据加上自己的标识传给会话层；以此类推，每一层都在收到的数据上加上本层的控制信息并传给下一层；最后到达物理层时,数据通过实际的物理媒体传到接收方。接收端则执行与发送端相反的操作，由下往上，将逐层标识去掉，重新还原成最初的数据。由此可见,数据通讯双方在对等层必须采用相同的协议，定义同一种数据标识格式，这样才可能保证数据的正确传输。

这个模型学了好多次，总是记不住。今天又看了一遍，发现用历史推演的角度去看问题会更有逻辑，更好记。本文不一定严谨，可能有错漏，主要是抛砖引玉，帮助记性不好的人。总体来说，OSI模型是从底层往上层发展出来的。

 这个模型推出的最开始，是是因为美国人有两台机器之间进行通信的需求。

### **需求1：**

科学家要解决的第一个问题是，两个硬件之间怎么通信。具体就是一台发些比特流，然后另一台能收到。于是，科学家发明了 物理层：

主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。

### 需求2：

现在通过电线我能发数据流了，但是，我还希望通过无线电波，通过其它介质来传输。然后我还要保证传输过去的比特流是正确的，要有纠错功能。

于是，发明了 数据链路层：

定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。

### 需求3：

现在我能发正确的发比特流数据到另一台计算机了，但是当我发大量数据时候，可能需要好长时间，例如一个视频格式的，网络会中断好多次（事实上，即使有了物理层和数据链路层，网络还是经常中断，只是中断的时间是毫秒级别的）。

那么，我还须要保证传输大量文件时的准确性。于是，我要对发出去的数据进行封装。就像发快递一样，一个个地发。

于是，先发明了 传输层（传输层在OSI模型中，是在网络层上面）

例如TCP，是用于发大量数据的，我发了1万个包出去，另一台电脑就要告诉我是否接受到了1万个包，如果缺了3个包，就告诉我是第1001，234，8888个包丢了，那我再发一次。这样，就能保证对方把这个视频完整接收了。

例如UDP，是用于发送少量数据的。我发20个包出去，一般不会丢包，所以，我不管你收到多少个。在多人互动游戏，也经常用UDP协议，因为一般都是简单的信息，而且有广播的需求。如果用TCP，效率就很低，因为它会不停地告诉主机我收到了20个包，或者我收到了18个包，再发我两个！如果同时有1万台计算机都这样做，那么用TCP反而会降低效率，还不如用UDP，主机发出去就算了，丢几个包你就卡一下，算了，下次再发包你再更新。

TCP协议是会绑定IP和端口的协议，下面会介绍IP协议。

### 需求4：

传输层只是解决了打包的问题。但是如果我有多台计算机，怎么找到我要发的那台？或者，A要给F发信息，中间要经过B，C，D,E，但是中间还有好多节点如K.J.Z.Y。我怎么选择最佳路径？这就是路由要做的事。

于是，发明了 网络层。即 [路由器](http://www.2cto.com/net/router/)， [交换机](http://www.2cto.com/net/switch/)那些具有寻址功能的设备所实现的功能。这一层定义的是IP地址，通过IP地址寻址。所以产生了IP协议。

### 需求5：

现在我们已经保证给正确的计算机，发送正确的封装过后的信息了。但是用户级别的体验好不好？难道我每次都要调用TCP去打包，然后调用IP协议去找路由，自己去发？当然不行，所以我们要建立一个自动收发包，自动寻址的功能。

于是，发明了 会话层。会话层的作用就是建立和管理应用程序之间的通信。

### 需求6：

现在我能保证应用程序自动收发包和寻址了。但是我要用Linux给window发包，两个 [系统](http://www.2cto.com/os/)语法不一致，就像安装包一样，exe是不能在linux下用的，shell在window下也是不能直接运行的。于是需要 表示层（presentation），帮我们解决不同系统之间的通信语法问题。

### 需求7：

OK，现在所有必要条件都准备好了，我们可以写个android程序，web程序去实现需求了。

### 补充：

Socket：

这不是一个协议，而是一个通信模型。其实它最初是伯克利加州分校软件研究所，简称BSD发明的，主要用来一台电脑的两个进程间通信，然后把它用到了两台电脑的进程间通信。所以，可以把它简单理解为进程间通信，不是什么高级的东西。主要做的事情不就是：

A发包：发请求包给某个已经绑定的端口（所以我们经常会访问这样的地址182.13.15.16:1235，1235就是端口）；收到B的允许；然后正式发送；发送完了，告诉B要断开链接；收到断开允许，马上断开，然后发送已经断开信息给B。

B收包：绑定端口和IP；然后在这个端口监听；接收到A的请求，发允许给A，并做好接收准备，主要就是清理缓存等待接收新数据；然后正式接收；接受到断开请求，允许断开；确认断开后，继续监听其它请求。

可见，Socket其实就是I/O操作。Socket并不仅限于网络通信。在网络通信中，它涵盖了网络层、传输层、会话层、表示层、应用层——其实这都不需要记，因为Socket通信时候用到了IP和端口，仅这两个就表明了它用到了网络层和传输层；而且它无视多台电脑通信的系统差别，所以它涉及了表示层；一般Socket都是基于一个应用程序的，所以会涉及到会话层和应用层。