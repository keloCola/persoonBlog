---
title: 产互面经
date: 2021-07-15 17:36:13
permalink: /pages/4902a1/
categories:
  - 面经
tags:
    - 一面
    - 二面
    - 三面
---
## this的指向情况，举例说明

### `this` 只依赖于调⽤函数前的对象

```js
function foo() {
console.log(this.a)
}
var a = 1
foo()
var obj = {
a: 2,
foo: foo
}
obj.foo()
```

- 对于直接调⽤ foo 来说，不管 foo 函数被放在了什么地⽅， this ⼀定是window
- 对于 obj.foo() 来说，我们只需要记住，谁调⽤了函数，谁就是 this ，所以在这个场
  景下 foo 函数中的 this 就是 obj 对象

### `this` 只会绑定在实例 `c` 上，不会被任何⽅式修改 `this` 指向

```js
var c = new foo()
c.a = 3
console.log(c.a)
```

- 对于 new 的⽅式来说， this 被永远绑定在了 c 上⾯，不会被任何⽅式改变 this

### 利⽤ call，apply，bind 改变 this

```js
function foo() {
console.log(this.a)
}
foo().bind(this)
```

### 箭头函数中的this

```js
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(a()()())
```

- ⾸先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第⼀个普通函数的 this 。在这个例⼦中，因为包裹箭头函数的第⼀个普通函数是 a ，所以此时的 this 是 window 。另外对箭头函数使⽤ bind 这类函数是⽆效的。

### 优先级总结

⾸先， `new `的⽅式优先级最⾼，接下来是 `bind `这些函数，然后是`obj.foo() `这种调⽤⽅式，最后是` foo `这种调⽤⽅式，同时，箭头函数的this ⼀旦被绑定，就不会再被任何⽅式所改变。

##   this的指向能否改变 比如说new  this指向如何改变

可以 参考上文

##   new的过程发生了什么

在调⽤ new 的过程中会发⽣四件事情

- 新⽣成了⼀个对象
- 链接到原型
- 绑定 this
- 返回新对象

##   有什么方法可以实现深拷贝

- `JSON.parse(JSON.stringify(object))`


### 扩展 手写深拷贝

```js
function deepClone(obj={}){
    if(typeof obj !== 'object'||obj==null){
        //obj 是null或者obj不是对象和数组 直接放回
        return obj
    }
    //初始化返回结果
    let result 
    if(obj instanceof Array){
        result = []
    }else{
        result = {}
    }
    for(let key in obj){
        //保证key不是原形的属性
        if(obj.hasOwnProperty(key)){
            //递归调用
            result[key] = deepClone(obj[key])
        }
    }
    //返回最终结果
    return result
    
}


const obj1 = {
    age: 20,
    name: 'xxx',
    address: {
        city: 'beijing'
    },
    arr: ['a', 'b', 'c']
}
const obj2 = deepClone(obj1)
```



## 节流防抖

### 节流debounce

考虑⼀个场景，滚动事件中会发起⽹络请求，但是我们并不希望⽤户在滚动过程中⼀直发起请求，⽽是隔⼀段时间发起⼀次，对于这种情况我们就可以使⽤节流

### 防抖throttle

考虑⼀个场景，有⼀个按钮点击会触发⽹络请求，但是我们并不希望每次点击都发起⽹络请求，⽽是当⽤户点击按钮⼀段时间后没有再次点击的情况才去发起⽹络请求，对于这种情况我们就可以使⽤防抖

### 扩展 手写节流防抖

```js
function debounce(f, wait) {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            f(...args);
        }, wait);
    }
}

function throttle(f, wait) {
    let timer;
    return (...args) => {
        if (timer) { return };
        timer = setTimeout(() => {
            fn(...args);
            timer = null;
        }, wait);
    }
}
```



## 定时器问题，准确吗？如何优化，比方说动画怎样不卡顿

- 浏览器的多线程模式 && js的单线程执行逻辑， 注定setTimeout、 setInterval  是非准确的 。
- 比如 一个完善的定时任务逻辑 是这样，
-  Js 代码执行到 setTimeout 异步任务 ，会把异步任务推送到定时器线程， 定时器线程开始倒计时， 
- 当倒计时结束，会把异步任务中的 回调函数 ，压入到js  的宏任务队列中，  
- 此时 如果js 线程的执行栈中有大量的 耗时任务，显然会延迟事件循环 
- 从宏任务队列中 取出回调函数到执行栈中执行

### 优化方式

HTML5 给出一个新的API   `window.requestAnimationFrame`  其本身 用来更好的渲染动画效果 ，

window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配，通常是60次每秒。

所以我们改造一下

```js
function  mySetTimeOut(callBack , interval) {
  let timer={value:undefined} ; 
  const now = Date.now ;
  let startTime = now();
  let endTime = startTime ;
  const loop =  () => {
    timer.value = window.requestAnimationFrame(loop);
    endTime = now () ;
   if (endTime-startTime >= interval){
       endTime = startTime = now();
       cancelAnimationFrame(timer.timer);
       callBack&&callBack(timer);
    }
}
    timer.value = window.requestAnimationFrame(loop); 
     console.log('timer',timer);
     return timer ; 
  }
 
function clearMySettimeout (timer){
   timer&&timer.value &&cancelAnimationFrame(timer.value) ;
}
 
  const timer= mySetTimeOut(()=>{},1000); 
```

模拟一下setInterval

```js
function  mySetInterval(callBack , interval) {
  let timer={value:undefined} ; 
  const now = Date.now ;
  let startTime = now();
  let endTime = startTime ;
  const loop =  () => {
    timer.value = window.requestAnimationFrame(loop);
    endTime = now () ;
   if (endTime-startTime >= interval){
       endTime = startTime = now();
       callBack&&callBack();
    }
}
    timer.value = window.requestAnimationFrame(loop); 
     return timer ; 
  }
 
function clearMysetInterval (timer){
   timer&&timer.value &&cancelAnimationFrame(timer.value) ;
}
 
  const timer= mySetInterval(()=>{},1000); 
```



##  在地址输入url，vue_router怎么处理的，让我们看到的

### hash模式的特点

hash表示的是地址栏URL中#符号(也称作为锚点), hash虽然会出现在URL中, 但是不会被包含在Http请求中, 因此hash值改变不会重新加载页面.

由于hash值变化不会引起浏览器向服务器发出请求, 而且hash改变会触发hashchange事件, 浏览器的进后退也能对其进行控制, 所以在HTML5之前, 基本都是使用hash来实现前端路由.

通过hash改变了url，会触发hashchange事件，只要监听hashchange事件，就能捕获到通过hash改变url的行为。

```js
window.onhashchange=function(event){
  console.log(event);
}
//或者
window.addEventListener('hashchange',function(event){
   console.log(event);
})

```

当hash值改变时，输出一个HashChangeEvent。该HashChangeEvent的具体值为：

```js
{isTrusted: true, oldURL: "http://localhost:3000/", newURL:   "http://localhost:3000/#teg", type: "hashchange".....}

```

有了监听事件，且改变hash页面不刷新，这样我们就可以在监听事件的回调函数中，执行我们展示和隐藏不同UI显示的功能，从而实现前端路由。



### 使用hash实现路由切换

```html
//首先我们要有个html
  <ul>
      <li><a href="#luyou1">路由1</a></li>
      <li><a href="#luyou2">路由2</a></li>
      <li><a href="#luyou3">路由3</a></li>
    </ul>
    <div id="luyouid"></div>

```



```ts
//ts逻辑
      class router {
        //存贮当前路由
        hashStr: String;
        constructor(hash: String) {
          //初始化赋值
          this.hashStr = hash;
          //初始化
          this.watchHash();
          //绑定监听改变事件,由于this被换了，必须用bind绑定
          this.watch = this.watchHash.bind(this);
          window.addEventListener("hashchange", this.watch);
        }
        //监听方法
        watchHash() {
          console.log();
          let hash: String = window.location.hash.slice(1);
          this.hashStr = hash;
          console.log(hashStr);
          if (hashStr) {
            if (hashStr == "luyou1") {
              document.querySelector("#luyouid").innerHTML = "好好学习天天向上";
            } else if (hashStr == "luyou2") {
              document.querySelector("#luyouid").innerHTML = "天天向上好好学习";
            } else {
              document.querySelector("#luyouid").innerHTML = "学习向上";
            }
          }
        }
      }

```





### history模式的特点

利用了HTML5新增的`pushState()`和`replaceState()`两个api, 通过这两个api完成URL跳转不会重新加载页面

同时history模式解决了hash模式存在的问题. hash的传参是基于URL的, 如果要传递复杂的数据, 会有体积限制, 而history模式不仅可以在URL里传参, 也可以将数据存放到一个特定的对象中

```js
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录

```



## vue中key有什么用？能使用index吗，有什么影响

**key的作用主要是为了高效的更新虚拟DOM** 。通过这个 key，我们的 diff 操作可以更准确、更快速

但是 不能使用index , 更新DOM的时候会出现性能问题，会发生一些状态变化

比如

```js
const list = [
    {
        id: 1,
        name: "Person1"
    },
    {
        id: 2,
        name: "Person2"
    },
    {
        id: 3,
        name: "Person3"
    },
    {
        id:4,
        name:"Person4"
    }
];

```

此时，删除 “Person4” 是正常的，但是如果我删除 “Person2” 就会出现问题。

删除前

| key  | id   | index | name    |
| ---- | ---- | ----- | ------- |
| 0    | 1    | 0     | Person1 |
| 1    | 2    | 1     | Person2 |
| 2    | 3    | 2     | Person3 |
| 3    | 4    | 3     | Person4 |

删除后

| key  | id   | index | name    |
| ---- | ---- | ----- | ------- |
| 0    | 1    | 0     | Person1 |
| 1    | 3    | 1     | Person3 |
| 2    | 4    | 2     | Person4 |

这个时候，除了 Person1 之外，剩下的 Person3、Person4，因为被发现与相应 key 的绑定关系有变化，所以被重新渲染，这会影响性能。
如果此时 list 的 item 是 select 的选项，其中 Person3 是选中的，这个时候 Person2 被删除了，用 index 作为 key 就会变成是 Person4 选中的了，这就产生了bug。

如果使用唯一id作为key，删除 Person2 后，剩下的元素因为与 key 的关系没有发生变化，都不会被重新渲染，从而达到提升性能的目的。此时，list 的 item 作为 select 的选项，也不会出现上面所描述的bug。
##  时间轮训了解吗，在settimeout中当一个微任务，执行怎么样的

JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task （有多种 task ） 队列中。⼀旦执⾏栈为空，Event Loop 就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说 JS 中的异步还是同步⾏为

不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 `微任务（ microtask ）` 和 `宏任务（ macrotask ）`。在 ES6 规范中，microtask 称为 jobs ， macrotask 称为 task

所以正确的⼀次 Event loop 顺序是这样的

- 执⾏同步代码，这属于宏任务
- 执⾏栈为空，查询是否有微任务需要执⾏ 
- 执⾏所有微任务
- 必要的话渲染 UI
- 然后开始下⼀轮 Event loop ，执⾏宏任务中的异步代码

## Jenkins自动化部署失败怎么办

## 项目如何迭代更新

## 有没有自己的输出

##  团队中扮演的角色