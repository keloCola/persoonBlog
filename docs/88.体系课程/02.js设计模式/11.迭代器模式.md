---
title:  迭代器模式
date: 2021-07-25 23:12:11
permalink: /pages/5fec23/
categories:
  - 体系课程
  - js设计模式
tags:
  - 
---
# 第11章 迭代器模式

用于顺序访问集合对象的元素，是的，就是循环。自己封装，通用的循环方法就是迭代器模式的经典实现。

## 11-1 迭代器模式-介绍

- `顺序访问`一个集合【有序列表
- 使用者无需知道集合的内部结构（封装）
<!-- more -->
### 实例

![image-20210725212708672](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725212708.png)



```js
/* 
顺序遍历有序集合
使用不知道内部封装方式
 */

var arr = [1,2,3]
var nodeList = document.getElementsByTagName('a')
var $a = $('a')

function each(data){
  var $data = $(data) //生成迭代器
  // 继承jquery中的each函数
  $data.each(function(key,val){
    console.log(key,val);
  })
}

// 执行循环
each(arr)
each(nodeList)
each($a)
```



## 传统UML类图

![image-20210725213602308](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725213602.png)

## 简化后的UML类图

![](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725213707.png)

## 迭代器模式基本代码

```js {26-29}
class Iterator {
  constructor(conatiner) {
      this.list = conatiner.list
      this.index = 0
  }
  next() {
      if (this.hasNext()) {
          return this.list[this.index++]
      }
      return null
  }
  // 是否有下一项
  hasNext() {
      if (this.index >= this.list.length) {
          return false
      }
      return true
  }
}

class Container {
  constructor(list) {
      this.list = list
  }
  // 生成遍历器
  getIterator() {
      return new Iterator(this)
  }
}

// 测试代码
let container = new Container([1, 2, 3, 4, 5])
let iterator = container.getIterator()//生成遍历器
while(iterator.hasNext()) {
  console.log(iterator.next())
}
```



## 11-3 迭代器模式-场景-JQuery ecah

::: details

![image-20210725214245536](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725214245.png)

```js
/* 
顺序遍历有序集合
使用不知道内部封装方式
 */

var arr = [1,2,3]
var nodeList = document.getElementsByTagName('a')
var $a = $('a')

function each(data){
  var $data = $(data) //生成迭代器
  // 继承jquery中的each函数
  $data.each(function(key,val){
    console.log(key,val);
  })
}

// 执行循环
each(arr)
each(nodeList)
each($a)
```

:::

## 11-4 迭代器模式-场景-ES6 Iterator

- Iterator 是es6实现迭代器的最佳方法
- ES6语法中，`有序集合的数据类型`已经有很多
- Array Map Set String TypedArray arguments NodeList 
- 需要有一个统一的遍历接口来遍历所有数据类型

>注意，object不是有序集合，可以用Map代替

- 有序数据类型,都有`[Symbol.iterator]`属性
- 属性值是函数，执行函数返回一个`迭代器`
- 这个迭代器就有`next`方法可`顺序迭代`子元素
- 可运行`Array.prototype[Symbol.iterator]`来测试

![image-20210725215238264](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725215238.png)

### es6使用基本方法

```js {3}
function each(data) {
    // 生成遍历器
    let iterator = data[Symbol.iterator]()

    // console.log(iterator.next())  // 有数据时返回 {value: 1, done: false}
    // console.log(iterator.next())
    // console.log(iterator.next())
    // console.log(iterator.next())
    // console.log(iterator.next())  // 没有数据时返回 {value: undefined, done: true}

    let item = {done: false}
    while (!item.done) {
        item = iterator.next()
        if (!item.done) {
            console.log(item.value)
        }
    }
}
```

### es6 正常迭代器使用方式

::: tip

`[Symbol.iterator]`并不是每个人都知道的，也不是每个人都需要封装一个each方法

因此有了`for...of`语法

:::

```js {2}
function each(data){
    for(let item of data){
        console.log(item)
    }
}

each([1,2,3])
```

### 演示下es6的迭代器

```js
let arr = [1, 2, 3, 4]
let nodeList = document.getElementsByTagName('p')
let m = new Map() // object不是有序的 所以用map代替
m.set('a', 100)
m.set('b', 200)

function each(data) {
  for (let item of data) {
    console.log(item)
  }
}

each(arr)
each(nodeList)
each(m)

```



## ES6 Iterator 与 Generator

- Iterator 的价值不限于上述几个类型的遍历
- 还有Generator函数的使用
- 即只要返回的数据符合Iterator接口的要求
- 即`可使用Iterator语法，这就是迭代器模式`

![image-20210725220534195](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725220534.png)

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
```



## 设计原则验证

- 迭代器对象和目标对象分离
- 迭代器将使用者与目标对象隔离开
- 符合开放封闭原则

# 