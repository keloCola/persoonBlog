---
title: 状态模式
date: 2021-07-25 23:12:54
permalink: /pages/9e0663/
categories:
  - 体系课程
  - js设计模式
tags:
  - 
---
# 第12章 状态模式

对于复杂的状态管理，如果只用 if…else来判断，扩展性是非常差的。状态模式提出了一种处理复杂状态变化且扩展性好的设计思路。有限状态机、自己实现Promise等场景的讲解，经典而深入

## 12-1 状态模式

- 一个对象有状态变化
- 每次状态变化都会触发一个逻辑
- 不能总是用` if…else `来控制
<!-- more -->
## 示例

- 交通信号灯的比那话

## 传统UML类图

![image-20210725221842835](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725221842.png)

## 简化后的UML类图

![image-20210725221902934](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210725221903.png)

## 状态模式基本代码

```js
// 状态 （ 红灯 绿灯 黄灯 ）
class State {
  constructor(color) {
      this.color = color
  }
  handle(context) {
      console.log(`turn to ${this.color} light`)
      // 获取状态
      context.setState(this)//将当前state的实例传到context中
  }
}
// 主体
class Context {
  constructor() {
      this.state = null
  }
  // 设置状态
  setState(state) {
      this.state = state
  }
  // 获取状态
  getState() {
      return this.state
  }
}

// 测试代码
// 生成主体实例
let context = new Context()

// 生成状态
let greed = new State('greed')
let yellow = new State('yellow')
let red = new State('red')

// 绿灯亮了
greed.handle(context)
console.log(context.getState())//打印出状态 turn to green light
// 黄灯亮了
yellow.handle(context)
console.log(context.getState())
// 红灯亮了
red.handle(context)
console.log(context.getState())


```



## 12-2 状态模式-场景-有限状态机

- 上述的红路灯就是一个有限状态机
- 有限个状态、以及在这些状态之间的变化
- 使用开源lib:[javascript-state-mechaine](https://github.com/jayphelps/core-decorators)

### 有限状态机—–‘收藏’和‘取消’

```js {5-31}
import StateMachine from './javascript-state-machine'
import $ from 'jQuery'
// 状态机模型
// 初始化状态机模型
var fsm = new StateMachine({
  init: '收藏',  // 初始状态，待收藏
  transitions: [
    {
      name: 'doStore',
      from: '收藏',
      to: '取消收藏'
    },
    {
      name: 'deleteStore',
      from: '取消收藏',
      to: '收藏'
    }
  ],
  methods: {
    // 监听执行收藏
    onDoStore: function () {
      alert('收藏成功') //可以post请求
      updateText()
    },
    // 监听取消收藏
    onDeleteStore: function () {
      alert('已取消收藏')//可以post请求
      updateText()
    }
  }
})

var $btn = $('#btn')

// 点击事件
$btn.click(function () {
  if (fsm.is('收藏')) {
    fsm.doStore()
  } else {
    fsm.deleteStore()
  }
})

// 更新文案
function updateText() {
  $btn.text(fsm.state)
}

// 初始化文案
updateText()

```

## 12-3 状态模式-场景2(写一个promise)

- Promise就是一个有限状态机
- 这边利用第三方库 简单写一个promise

### 引入第三方库

```js
import StateMachine from './javascript-state-machine'
```

### 状态机模型

```js
// 状态机模型 初始化
var fsm = new StateMachine({
  init: 'pending', //初始化状态
  transitions: [
    {
      name: 'resolve',//事件名称
      from: 'pending',
      to: 'fullfilled'
    },
    {
      name: 'reject',//事件名称
      from: 'pending',
      to: 'rejected'
    }
  ],
  methods: {
    // 监听 resolve 
    onResolve: function (state, data) {
      // 参数：state - 当前状态示例; data - fsm.resolve(xxx) 执行时传递过来的参数
      data.successList.forEach(fn => fn())
    },
    // 监听 reject
    onReject: function (state, data) {
      // 参数：state - 当前状态示例; data - fsm.reject(xxx) 执行时传递过来的参数
      data.failList.forEach(fn => fn())
    }
  }
})
```

### 目标promise

```js
// 定义 Promise
class MyPromise {
  constructor(fn) {
    this.successList = []
    this.failList = []

    fn(() => {
      // resolve 函数
      fsm.resolve(this)
    }, () => {
      // reject 函数
      fsm.reject(this)
    })
  }
  then(successFn, failFn) {
    this.successList.push(successFn)
    this.failList.push(failFn)
  }
}
```

### 测试用例

```js
// 测试代码
function loadImg(src) {
  const promise = new MyPromise(function (resolve, reject) {
    var img = document.createElement('img')
    img.onload = function () {
      resolve(img)
    }
    img.onerror = function () {
      reject()
    }
    img.src = src
  })
  return promise
}
var src = 'http://www.imooc.com/static/img/index/logo_new.png'
var result = loadImg(src)
console.log(result)

result.then(function (img) {
  console.log('success 1')
}, function () {
  console.log('failed 1')
})
result.then(function (img) {
  console.log('success 2')
}, function () {
  console.log('failed 2')
})
```



## 设计原则验证

- 将状态对象和主题对象分离，状态的变化逻辑单独处理
- 符合开放封闭原则

