---
title: 渲染优化
date: 2021-07-22 17:34:08
permalink: /pages/c01b3b/
categories:
  - 体系课程
  - 性能优化
tags:
  - 
---

# 1 浏览器渲染原理和关键渲染路径

关键渲染路径（`critical rendering path`）

## 浏览器渲染流程

JavaScript—–>Style—–>Layout(布局)—–>Paint（绘制）—–>Composite（合成）

## 浏览器构建对象模型

- 构建DOM对象
  - HTML—–>DOM
- 构建CSSOM对象
  - CSS—–>CSSOM

## 浏览器构建渲染树

DOM+CSSOM —–> Render Tree

## 布局与绘制

- 布局记住 位置和大小
- 绘制 画出来
- 渲染树只包含网页需要的节点
- 布局计算每个节点精确的位置和大小 —–“盒模型”
- 绘制是像素化每个节点的过程

## 影响布局-回流的操作

- 添加/删除元素
- 操作Styles
- display：none
- offsetLeft，scrollTop，clientWidth
- 移动元素位置
- 修改浏览器大小，字体大小

# 2 回流与重绘, 如何避免布局抖动

## 连续布局操作导致强制布局更新来制造一下布局抖动

```js
// 获取页面上的卡片
let card = document.getElementsByClassName('aaa')
// 修改卡片宽度
const update=(timeStamp)=>{
    for(let i = 0;i<card.length;i++){
        // 通过offsetTop计算修改width
        card[i].style.width = ((Math.sin(card[i].offsetTop+timeStamp/1000)+1)*500)+'px'

    }
    window.requestAnimationFrame(update)
}
```

## 避免布局抖动

- 避免回流 translate
- 读写分离

# 3 使用FastDom【防止布局抖动的利器】

- 读 measure
- 写 mutate

```js
//  首先在HTML中引入fastDom文件
// <script src='./fastDom.js'></script>
// 获取页面上的卡片
let card = document.getElementsByClassName('aaa')
// 修改卡片宽度
const update = (timeStamp) => {
    for (let i = 0; i < card.length; i++) {
        //fastDom 读取
        fastdom.measure(() => {
            //    读取top值
            let top = card[i].offsetTop
            //    fastDom 赋值
            fastdom.mutate(() => {
                // 通过offsetTop计算修改width
                card[i].style.width = ((Math.sin(top + timeStamp / 1000) + 1) * 500) + 'px'

            })
        })

    }
    window.requestAnimationFrame(update)
}
```



# 4 复合线程(compositor thread)与图层(layers)

`拆分成多个图层以便于绘制`

- 将页面拆分图层进行绘制再进行复合
- 利用DevTools了解网页的图层拆分情况
- 那些样式仅影响复合（`只触发复合不影响布局和重绘`）
  - position ：transform：translate（npx,npx）—–移动
  - scale:transform:scale(n)  —大小
  - Rotation: transform:rotate(n deg)  —–旋转
  - Opacity : opacity:0…1                  —–透明

![image-20210714151721296](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714151721.png)



#  5 避免重绘

## chrome 工具设置

![image-20210714152805035](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714152805.png)

![image-20210714153102566](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714153102.png)

## 解决方案 利用will-change创建新的图层

劲量使用transform 和 提取到单独图层

![image-20210714153528134](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714153528.png)

```js
@keyframes rotate {
    0% {
        transform: rotate(0deg);
        opacity: 0.1;
        /*width: 300px;*/
        /*transform: scaleX(1);*/
    }
    50% {
        opacity: 0.5;
    }
    100% {
        transform: rotate(360deg);
        opacity: 0.1;
        /*width: 600px;*/
        /*transform: scaleX(2);*/
    }
}

```



#  6 高频事件防抖

滚动 touch 等等

## 问题复现

## 一帧的生命周期

![一帧的生命周期](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714154618.png)

## 解决问题

改进将实际触发的任务`changeWidth(pos);`放在`requestAnimationFrame`里面，

```js
        window.requestAnimationFrame(() => {
            changeWidth(pos);
        });
```

但这里还有一个问题，这里触发频率非常高的`pointermove`事件,如果一帧之内多次触发`requestAnimationFrame`也是没有意义的，我希望它一帧内只触发一次，这就是去抖动（debounce），通过一个变量`ticking`就可以控制住：

```js
let cards = document.getElementsByClassName('aaa');

//修改图片宽度
function changeWidth(position) {
    for (let i = 0; i < cards.length; i++) {
        cards[i].style.width = (Math.sin(position / 1000) + 1) * 500 + 'px';
    }
}

let ticking = false;
//利用Chrome DevTools来复现并分析抖动问题(pointer event)
window.addEventListener('pointermove', (e) => {
    let pos = e.clientX //获取鼠标的横坐标位置
    if (ticking) return; //如果ticking为true，说明已经有个requestAnimationFrame执行了

    ticking = true; //如果ticking为true，说明已经有个requestAnimationFrame执行了
    window.requestAnimationFrame(() => {
        changeWidth(pos);
        //如果requestAnimationFrame里面的事情执行了，ticking再调整回false，接着又可以触发下一个requestAnimationFrame，这样即使pointermove的触发频率很高我们也不按照它实际的触发频率去触发，而是按照requestAnimationFrame调度的频率。
        ticking = false;
    });
})
```

# 7 React时间调度实现【中高级前端需要了解的React调度原理】

- requestldlecallback的问题
- 通过rAF模拟rIC

## 什么是requestIdleCallback?

当关注用户体验，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用requestIdleCallback。因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。

requestIdleCallback用法示例

```js
    requestIdelCallback(myNonEssentialWork);
    
    
    function myNonEssentialWork (deadline) {
    
      // deadline.timeRemaining()可以获取到当前帧剩余时间
      while (deadline.timeRemaining() > 0 && tasks.length > 0) {
        doWorkIfNeeded();
      }
      if (tasks.length > 0){
        requestIdleCallback(myNonEssentialWork);
      }
    }
```

## requestIdleCallback和requestAnimationFrame有什么区别？

requestAnimationFrame的回调会在每一帧确定执行，属于高优先级任务，而requestIdleCallback的回调则不一定，属于低优先级任务。 我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢，如下所示：



![](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160236.webp)

图中一帧包含了用户的交互、js的执行、以及requestAnimationFrame的调用，布局计算以及页面的重绘等工作。 假如某一帧里面要执行的任务不多，在不到16ms（1000/60)的时间内就完成了上述任务的话，那么这一帧就会有一定的空闲时间，这段时间就恰好可以用来执行requestIdleCallback的回调，如下图所示：

![image-20210714155715585](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160248.png)



当程序栈为空页面无需更新的时候，浏览器其实处于空闲状态，这时候留给requestIdleCallback执行的时间就可以适当拉长，最长可达到50ms，以防出现不可预测的任务（用户输入）来临时无法及时响应可能会引起用户感知到的延迟。



![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160301.webp)



由于requestIdleCallback利用的是帧的空闲时间，所以就有可能出现浏览器一直处于繁忙状态，导致回调一直无法执行，这其实也并不是我们期望的结果（如上报丢失），那么这种情况我们就需要在调用requestIdleCallback的时候传入第二个配置参数timeout了？

```js
requestIdleCallback(myNonEssentialWork, { timeout: 2000 });

function myNonEssentialWork (deadline) {
  // 当回调函数是由于超时才得以执行的话，deadline.didTimeout为true
  while ((deadline.timeRemaining() > 0 || deadline.didTimeout) &&
         tasks.length > 0) {
       doWorkIfNeeded();
    }
  if (tasks.length > 0) {
    requestIdleCallback(myNonEssentialWork);
  }
}

```

如果是因为timeout回调才得以执行的话，其实用户就有可能会感觉到卡顿了，因为一帧的执行时间必然已经超过16ms了

## requestIdleCallback里面可以执行DOM修改操作吗？

强烈建议不要，从上面一帧的构成里面可以看到，requestIdleCallback回调的执行说明前面的工作（包括样式变更以及布局计算）都已完成。如果我们在callback里面做DOM修改的话，之前所做的布局计算都会失效，而且如果下一帧里有获取布局（如getBoundingClientRect、clientWidth）等操作的话，浏览器就不得不执行强制重排工作,这会极大的影响性能，另外由于修改dom操作的时间是不可预测的，因此很容易超出当前帧空闲时间的阈值，故而不推荐这么做。推荐的做法是在requestAnimationFrame里面做dom的修改，可以在requestIdleCallback里面构建Document Fragment，然后在下一帧的requestAnimationFrame里面应用Fragment。

除了不推荐DOM修改操作外，Promise的resolve(reject)操作也不建议放在里面，因为Promise的回调会在idle的回调执行完成后立刻执行，会拉长当前帧的耗时，所以不推荐。

## requestIdleCallback的兼容情况

![img](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160339.webp)

