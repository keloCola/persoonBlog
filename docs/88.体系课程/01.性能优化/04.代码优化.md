---
title: 代码优化
date: 2021-07-22 17:36:45
permalink: /pages/c92558/
categories:
  - 体系课程
  - 性能优化
tags:
  - 
---

# 1 JS开销和如何缩短解析时间

![image-20210714160507374](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160507.png)

![image-20210714160616639](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160616.png)

![image-20210714160820467](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160820.png)

![1/3的时间都在处理JavaScript身上](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160850.png)

## 解决方法

![image-20210714160940318](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714160940.png)

## 减少主线程工作量

- 注意合理规划首屏脚本

![image-20210714161013759](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161013.png)

## 渐进式启动

![image-20210714161122817](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161122.png)

## 总结

![image-20210714161140375](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161140.png)

# 2 V8编译原理

![image-20210714161355617](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714161355.png)

![image-20210714162530620](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162530.png)

## 反优化的例子

```js
//在Node环境下运行
//引用
const {performance, PerformanceObserver} = require('perf_hooks');

const add = (a, b) => a+b;

const num1 = 1;
const num2 = 2;
//标记 开始测量
performance.mark('start');

for(let i = 0; i < 10000000; i++) {
	add(num1, num2);
}

// 在此之前的优化方式不适用于 下面的add 于是反优化之前方式，重新优化17行的add 耗能增加 可以通过注释来查看性能
// add(num1, 's');

for(let i = 0; i < 10000000; i++) {
	add(num1, num2);
}
//标记结束测量
performance.mark('end');
//进行一个监听 得到的对象
const observer = new PerformanceObserver((list) => {
	console.log(list.getEntries()[0]);
})
observer.observe({entryTypes: ['measure']});

//使用测量
performance.measure('测量1', 'start', 'end');
```

![image-20210714162215814](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162215.png)

## v8 的两个参数可以查看哪些优化哪些不优化

- `node --trace-opt` +文件名
- `node --trace-deopt` +文件名

![image-20210714162422218](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162422.png)

## 优化机制

- 脚本流
  - 超过30kb 会开一个新的来解析 后面再合并
- 字节码缓存
- 懒解析
  - 对于函数而言
  - 默认会开启
  - 真正用的时候才解析

# 3 函数优化

![image-20210714162757312](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714162757.png)

## 饥饿解析

默认情况是懒解析 有时候我们遇到想要直接解析的函数 

懒解析再转饥饿解析耗费性能

于是便有强制饥饿解析

```js
export default () => {
    const add = (a, b) => a*b; // lazy parsing
    // const add = ((a, b) => a*b); // eager parsing
    const num1 = 1;
    const num2 = 2;
    add(num1, num2);
}
```

懒解析：v8 遇到add 的时候 只是先记住，但不解析里面的结构，等到使用add的时候再去解析

饥饿解析：v8遇到add的时候就解析内部结构

## Optimize

在webpack4.0以前，压缩的过程中有可能会吧（）直接给弄没了

于是便有optimize.js来解决这个问题

Example input:

```js
!function (){}()
function runIt(fun){ fun() }
runIt(function (){})
```

Example output:

```js
!(function (){})()
function runIt(fun){ fun() }
runIt((function (){}))
```

# 4 对象优化【JS对象避坑地图】

- 以相同顺序初始化对象成员，避免隐藏类的调整
- 实例化后避免添加新属性
- 尽量使用Array代替array-like对象
- 避免读取超过数组的长度
- 避免元素类型转换

## 以相同顺序初始化对象成员，避免隐藏类的调整

- 底层隐藏类型 

```js
// HindClass 我们简称 HC
/* 1 */
class RectArea { // HC0 隐藏对象0
    constructor(l, w) {
        this.l = l; // HC1
        this.w = w; // HC2
    }
}

const rect1 = new RectArea(3,4); // 创建了隐藏类HC0, HC1, HC2
const rect2 = new RectArea(5,6); // 相同的对象结构，可复用之前的所有隐藏类
```

对比一下

```js
const car1 = {color: 'red'}; // HC0
car1.seats = 4; // HC1

const car2 = {seats: 2}; // 没有可复用的隐藏类，创建HC2
car2.color = 'blue'; // 没有可复用的隐藏类，创建HC3
```



## 实例化后避免添加新属性

不推荐这样做

```js
const car1 = {color: 'red'}; // In-object 属性
car1.seats = 4; // Normal/Fast 属性，存储在property store里，需要通过描述数组间接查找
```

## 尽量使用Array代替array-like对象

```js
//类数组的foreach实现
Array.prototype.forEach.call(arrObj, (value, index) => { // 不如在真实数组上效率高
  console.log(`${ index }: ${ value }`);
});
//推荐方式
const arr = Array.prototype.slice.call(arrObj, 0); // 转换的代价比影响优化小
arr.forEach((value, index) => {
  console.log(`${ index }: ${ value }`);
});
```

## 避免读取超过数组的长度

```js
function foo(array) {
  for (let i = 0; i <= array.length; i++) { // 越界比较
    if(array[i] > 1000) { // 1.沿原型链的查找 2.造成undefined与数进行比较
        console.log(array[i]); // 业务上无效、出错
    }
  }
}
//[0,100,1000]
```

## 避免元素类型转换

```js
const array = [3, 2, 1]; // PACKED_SMI_ELEMENTS 满——整形

array.push(4.4); // PACKED_DOUBLE_ELEMENTS

```

![image-20210714170129611](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210714170129.png)

# 5 HTML优化【必会】

- 减少iframes使用
- 压缩空白符
- 避免节点深层级嵌套
- 避免使用table布局（老程序员会）
  - 减少开销
- 删除注销
- CSS& JavaScript尽量使用外链接
- 删除元素默认属性

![image-20210722165628232](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210722165628.png)

![image-20210722165650965](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210722165651.png)

![image-20210722165930203](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210722165930.png)

## 借助工具

`html-minifier`

# 6 CSS对性能的影响 【必会】

## 利用DevTools测量样式计算开销

![image-20210722170142436](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210722170142.png)

## 优化的建议

- 降低CSS对渲染的阻塞
  - 由于这个阻塞是无法避免的
  - 尽量早的下载好css 并解析
  - 降低css的大小
- 利用GPU进行完成动画
  - 复合
  - transform
  - 单独一层，让GPU来优化
- 使用contain的属性
  - ![image-20210722170421422](https://gitee.com/sheep101/typora-img-save/raw/master/img/20210722170421.png)
- 使用font-display
  - 帮助我们让文字更早的显示在页面上
  - 减轻文字闪动问题